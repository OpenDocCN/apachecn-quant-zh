# 一、处理和操作日期、时间和时间序列数据

当谈到算法交易时，时间序列数据是无处不在的。因此，处理、管理和操纵时间序列数据对于成功执行算法交易是至关重要的。这一章有各种方法来演示如何使用 Python 标准库和`pandas`(一个 Python 数据分析库)来完成算法交易。

对于我们的上下文，时间序列数据是一系列数据，由等间距的时间戳和描述特定时间范围内交易数据的多个数据点组成。

在处理时间序列数据时，首先应该知道如何读取、修改和创建理解日期和时间的 Python 对象。Python 标准库包括`datetime`模块，该模块提供了`datetime`和`timedelta`对象，它们可以处理关于日期和时间的所有事情。本章的前七个食谱讲述了这个模块。本章的剩余部分将讨论如何使用`pandas`库处理时间序列数据，这是一个非常高效的数据分析库。在我们的食谱中会用到`pandas.DataFrame`类。

以下是本章中的配方列表:

*   创建日期时间对象
*   创建 timedelta 对象
*   对日期时间对象的操作
*   修改日期时间对象
*   将日期时间转换为字符串
*   从字符串创建日期时间对象
*   日期时间对象和时区
*   创造一只 Pandas。数据帧对象
*   数据帧操作—重命名、重新排列、反转和切片
*   数据帧操作—应用、排序、迭代和连接
*   将数据帧转换成其他格式
*   从其他格式创建数据帧

# 技术要求

要成功执行本章中的配方，您需要具备以下条件:

*   Python 3.7+版本
*   Python 包:
*   `pandas` ( `$ pip install pandas`)

对于本章中的所有食谱，您将需要本章的 Jupyter 笔记本，可在[https://github . com/packt publishing/Python-algorithm-Trading-Cookbook/tree/master/chapter 01](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter01)找到。

您也可以打开一个新的 Jupyter 笔记本，直接尝试食谱中显示的动手练习。请注意，其中一些食谱的输出可能因您而异，因为它们取决于当时提供的日期、时间和时区信息。

# 创建日期时间对象

`datetime`模块提供了一个`datetime`类，可以用来准确地捕获与时间戳、日期、时间和时区相关的信息。在这个菜谱中，你将通过多种方式创建`datetime`对象，并自省它们的属性。

## 怎么做…

按照以下步骤执行该配方:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime
```

2.  使用`now()`方法创建一个保存当前时间戳的`datetime`对象，并打印它:

```
>>> dt1 = datetime.now()
>>> print(f'Approach #1: {dt1}')
```

我们得到以下输出。您的输出会有所不同:

```
Approach #1: 2020-08-12 20:55:39.680195
```

3.  打印与日期和时间相关的`dt1`的属性:

```
>>> print(f'Year: {dt1.year}')
>>> print(f'Month: {dt1.month}')
>>> print(f'Day: {dt1.day}')
>>> print(f'Hours: {dt1.hour}')
>>> print(f'Minutes: {dt1.minute}')
>>> print(f'Seconds: {dt1.second}')
>>> print(f'Microseconds: {dt1.microsecond}')
>>> print(f'Timezone: {dt1.tzinfo}')
```

我们得到以下输出。您的输出会有所不同:

```
Year: 2020
Month: 8
Day: 12
Hours: 20
Minutes: 55
Seconds: 39
Microseconds: 680195
Timezone: None
```

4.  创建一个保存 2021 年 1 月 1 日时间戳的`datetime`对象:

```
>>> dt2 = datetime(year=2021, month=1, day=1)
>>> print(f'Approach #2: {dt2}')
```

您将获得以下输出:

```
Approach #2: 2021-01-01 00:00:00
```

5.  打印与日期和时间相关的`dt2`的各种属性:

```
>>> print(f'Year: {dt.year}')
>>> print(f'Month: {dt.month}')
>>> print(f'Day: {dt.day}')
>>> print(f'Hours: {dt.hour}')
>>> print(f'Minutes: {dt.minute}')
>>> print(f'Seconds: {dt.second}')
>>> print(f'Microseconds: {dt.microsecond}')
>>> print(f'Timezone: {dt2.tzinfo}')
```

您将获得以下输出:

```
Year: 2021
Month: 1
Day: 1
Hours: 0
Minutes: 0
Seconds: 0
Microseconds: 0
Timezone: None
```

## 它是如何工作的...

在*步骤 1* 中，您从`datetime`模块导入`datetime`类。在*步骤 2* 中，您使用`now()`方法创建并打印一个`datetime`对象，并将其分配给`dt1`。该对象保存当前的时间戳信息。

一个`datetime`对象具有以下与日期、时间和时区信息相关的属性:

| one | `year` | 0 到 23 之间的整数，包括 0 和 23 |
| Two | `month` | 1 到 12 之间的整数，包括 1 和 12 |
| three | `day` | 1 到 31 之间的整数，包括 1 和 31 |
| four | `hour` | 0 到 23 之间的整数，包括 0 和 23 |
| five | `minute` | 介于 0 和 59 之间的整数，包括 0 和 59 |
| six | `second` | 介于 0 和 59 之间的整数，包括 0 和 59 |
| seven | `microsecond` | 介于 0 和 999999 之间的整数，包括 0 和 99999 |
| eight | `tzinfo` | 类别为`timezone`的对象。(关于时区的更多信息在*日期时间对象和时区*方法中)。 |

在*步骤 3* 中，为`dt1`打印这些属性。您可以看到它们保存了当前的时间戳信息。

在*步骤 4* 中，您创建并打印另一个`datetime`对象。这次您创建了一个特定的时间戳，即 2021 年 1 月 1 日午夜。您用参数调用构造函数本身，参数为`year`作为`2021`、`month`作为`1`、`day`作为`1`。其他时间相关属性默认为`0`，时区默认为`None`。在*步骤 5* 中，打印`dt2`的属性。您可以看到它们保存的值与您在*步骤 4* 中传递给构造函数的值完全相同。

## 还有更多

您可以使用`datetime`对象的`date()`和`time()`方法提取日期和时间信息，分别作为`datetime.date`和`datetime.time`类的实例:

1.  使用`date()`方法从`dt1`中提取数据。注意返回值的类型。

```
>>> print(f"Date: {dt1.date()}")
>>> print(f"Type: {type(dt1.date())}")
```

您将获得以下输出。您的输出可能会有所不同:

```
Date: 2020-08-12
Type: <class 'datetime.date'>
```

2.  使用`time()`方法从`dt1`中提取数据。注意返回值的类型。

```
>>> print(f"Time: {dt1.time()}")
>>> print(f"Type: {type(dt1.time())}")
```

我们得到以下输出。您的输出可能有所不同:

```
Time: 20:55:39.680195
Type: <class 'datetime.time'>
```

3.  使用`date()`方法从`dt2`中提取数据。注意返回值的类型。

```
>>> print(f"Date: {dt2.date()}")
>>> print(f"Type: {type(dt2.date())}")
```

我们得到以下输出:

```
Date: 2021-01-01
Type: <class 'datetime.date'>
```

4.  使用`time()`方法从`dt2`中提取数据。注意返回值的类型。

```
>>> print(f"Time: {dt2.time()}")
>>> print(f"Type: {type(dt2.time())}")
```

我们得到以下输出:

```
Time: 00:00:00
Type: <class 'datetime.time'>
```

# 创建 timedelta 对象

`datetime`模块提供了一个`timedelta`类，可以用来表示与日期和时差相关的信息。在这个菜谱中，您将创建`timedelta`对象并对它们执行操作。

## 怎么做…

按照以下步骤来执行这个食谱:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import timedelta
```

2.  创建一个持续时间为 5 天的`timedelta`对象。将其分配给`td1`并打印:

```
>>> td1 = timedelta(days=5)
>>> print(f'Time difference: {td1}')
```

我们得到以下输出:

```
Time difference: 5 days, 0:00:00
```

3.  创建一个持续时间为 4 天的`timedelta`对象。将其分配给`td2`并打印:

```
>>> td2 = timedelta(days=4)
>>> print(f'Time difference: {td2}')
```

我们得到以下输出:

```
Time difference: 4 days, 0:00:00
```

4.  将`td1`和`td2`相加并打印输出:

```
>>> print(f'Addition: {td1} + {td2} = {td1 + td2}')
```

我们得到以下输出:

```
Addition: 5 days, 0:00:00 + 4 days, 0:00:00 = 9 days, 0:00:00
```

5.  从`td1`中减去`td2`并打印输出:

```
>>> print(f'Subtraction: {td1} - {td2} = {td1 - td2}')
```

我们将获得以下输出:

```
Subtraction: 5 days, 0:00:00 - 4 days, 0:00:00 = 1 day, 0:00:00
```

6.  将`td1`乘以一个数字(一个`float`):

```
>>> print(f'Multiplication: {td1} * 2.5 = {td1 * 2.5}')
```

我们得到以下输出:

```
Multiplication: 5 days, 0:00:00 * 2.5 = 12 days, 12:00:00
```

## 它是如何工作的...

在*步骤 1* 中，您从`datetime`模块导入`timedelta`类。在*步骤 2* 中，您创建一个`timedelta`对象，保存一个`5 days`的时间差值，并将其分配给`td1`。您调用构造函数来创建具有单个属性`days`的对象。您在这里将值作为`5`传递。类似地，在*步骤 3* 中，您创建另一个`timedelta`对象，它保存一个`4 days`的时间差值，并将其分配给`td2`。

在接下来的步骤中，您将对`timedelta`对象执行操作。在*第 4 步*中，添加`td1`和`td2`。这将返回另一个`timedelta`对象，该对象保存有一个`9 days`的时间差值，该时间差值是`td1`和`td2`保存的时间差值的总和。在*步骤 5* 中，你从`td1`中减去`td2`。这将返回另一个`timedelta`对象，该对象保存一个时间差值`1 day`，它是由`td1`和`td2`保存的时间差值的差。在*第 6 步*中，你将`td1`乘以`2.5`，一个`float`。这再次返回一个`timedelta`对象，它保存了 12 天半的时间差值。

## 还有更多

可以使用一个或多个可选参数创建一个`timedelta`对象:

| one | `weeks` | 整数。默认值为 0。 |
| Two | `days` | 整数。默认值为 0。 |
| three | `hours` | 整数。默认值为 0。 |
| four | `minutes` | 整数。默认值为 0。 |
| five | `seconds` | 整数。默认值为 0。 |
| six | `milliseconds` | 整数。默认值为 0。 |
| seven | `microseconds` | 整数。默认值为 0。 |

在*步骤 2* 和*步骤 3* 中，我们只使用了`days`参数。您也可以使用其他参数。此外，这些属性在创建时会被规范化。对`timedelta`对象的这种规范化是为了确保每个可以保存的时间差值总是有一个唯一的表示。下面的代码演示了这一点:

1.  创建一个`timedelta`对象，小时为`23`，分钟为`59`，秒为`60`。分配给`td3`并打印。它将被规范化为一个`timedelta`对象，其中`days`为`1`(其他日期和时间相关属性为`0`):

```
>>> td3 = timedelta(hours=23, minutes=59, seconds=60)
>>> print(f'Time difference: {td3}')
```

我们得到以下输出:

```
Time difference: 1 day, 0:00:00
```

`timedelta`对象有一个方便的方法，`total_seconds()`。这个方法返回一个`float`,它表示包含在由`timedelta`对象持有的持续时间中的总秒数。

2.  在`td3`上调用`total_seconds()`方法。你得到`86400.0`作为输出:

```
>>> print(f'Total seconds in 1 day: {td3.total_seconds()}')
```

我们得到以下输出:

```
Total seconds in 1 day: 86400.0
```

# 对日期时间对象的操作

`datetime`和`timedelta`类支持各种数学运算来获得未来或过去的日期。使用这些操作返回另一个`datetime`对象。。在这个菜谱中，您将创建`datetime`、`date`、`time`和`timedelta`对象，并对它们执行数学运算。

## 怎么做…

按照以下步骤来执行这个食谱:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime, timedelta
```

2.  获取今天的日期。将其分配给`date_today`并打印:

```
>>> date_today = date.today()              
>>> print(f"Today's Date: {date_today}")
```

我们得到以下输出。您的输出可能有所不同:

```
Today's Date: 2020-08-12
```

3.  使用`timedelta`对象在今天的日期上添加 5 天。将其分配给`date_5days_later`并打印:

```
>>> date_5days_later = date_today + timedelta(days=5)
>>> print(f"Date 5 days later: {date_5days_later}")
```

我们得到以下输出。您的输出可能有所不同:

```
Date 5 days later: 2020-08-17
```

4.  使用`timedelta`对象从今天的日期中减去 5 天。将其分配给`date_5days_ago`并打印:

```
>>> date_5days_ago = date_today - timedelta(days=5)
>>> print(f"Date 5 days ago: {date_5days_ago}")
```

我们得到以下输出。您的输出可能有所不同:

```
Date 5 days ago: 2020-08-07
```

5.  使用`>`运算符将`date_5days_later`与`date_5days_ago`进行比较:

```
>>> date_5days_later > date_5days_ago
```

我们得到以下输出:

```
True
```

6.  使用`<`运算符将`date_5days_later`与`date_5days_ago`进行比较:

```
>>> date_5days_later < date_5days_ago
```

我们得到以下输出:

```
False
```

7.  使用`>`运算符将`date_5days_later`、`date_today`和`date_5days_ago`一起比较:

```
>>> date_5days_later > date_today > date_5days_ago
```

我们得到以下输出:

```
True
```

8.  获取当前时间戳。将其分配给`current_timestamp`:

```
>>> current_timestamp = datetime.now()
```

9.  获取当前时间。将其分配给`time_now`并打印:

```
>>> time_now = current_timestamp.time()
>>> print(f"Time now: {time_now}")
```

我们得到以下输出。您的输出可能有所不同:

```
Time now: 20:55:45.239177
```

10.  使用`timedelta`对象将当前时间增加 5 分钟。将其分配给`time_5minutes_later`并打印:

```
>>> time_5minutes_later = (current_timestamp + 
                                timedelta(minutes=5)).time()
>>> print(f"Time 5 minutes later: {time_5minutes_later}")
```

我们得到以下输出。您的输出可能有所不同:

```
Time 5 minutes later: 21:00:45.239177
```

11.  使用`timedelta`对象从当前时间减去 5 分钟。将其分配给`time_5minutes_ago`并打印:

```
>>> time_5minutes_ago = (current_timestamp - 
                            timedelta(minutes=5)).time()
>>> print(f"Time 5 minutes ago: {time_5minutes_ago}")
```

我们得到以下输出。您的输出可能有所不同:

```
Time 5 minutes ago: 20:50:45.239177
```

12.  使用`<`运算符将`time_5minutes_later`与`time_5minutes_ago`进行比较:

```
>>> time_5minutes_later < time_5minutes_ago
```

我们得到以下输出。您的输出可能有所不同:

```
False
```

13.  使用`>`运算符将`time_5minutes_later`与`time_5minutes_ago`进行比较:

```
>>> time_5minutes_later > time_5minutes_ago
```

我们得到以下输出。您的输出可能有所不同:

```
True
```

14.  使用`>`运算符将`time_5minutes_later`、`time_now`和`time_5minutes_ago`一起比较:

```
>> time_5minutes_later > time_now > time_5minutes_ago
```

我们得到以下输出。您的输出可能有所不同:

```
True
```

## 它是如何工作的…

在*步骤 1* 中，您从`datetime`模块导入`date`、`datetime`和`timedelta`类。在*步骤 2* 中，您使用类`date`提供的`today()` `classmethod`获取今天的日期，并将其赋给一个新属性`date_today`。(一个`classmethod`允许你直接在一个类上调用一个方法，而不用创建一个实例。)返回对象的类型是`datetime.date`。在*步骤 3* 中，您通过向`date_today`添加一个持续时间为 5 天的`timedelta`对象来创建一个比今天提前 5 天的日期。您将它分配给一个新属性，`date_5days_later`。类似地，在*步骤 4* 中，您创建了一个 5 天前的日期，并将其分配给一个新属性`date_5days_ago`。

在*步骤 5* 和*步骤 6* 中，分别使用`>`和`<`运算符比较`date_5days_later`和`date_5days_ago`。如果第一个操作数保存的日期早于操作数 2 保存的日期，则`>`运算符返回`True`。类似地，如果第二个操作数保存的日期早于操作数 1 保存的日期，则`<`运算符返回`True`。在*步骤 7* 中，您将目前创建的所有三个日期对象进行比较。注意输出。

*第 8 步*至*第 14 步*执行与*第 2 步*至*第 7 步*相同的操作，但这次是在`datetime.time`对象上——获取当前时间，获取当前时间前 5 分钟的时间，获取当前时间前 5 分钟的时间，并比较所有创建的`datetime.time`对象。不能将`timedelta`对象直接添加到`datetime.time`对象中以获得过去或未来的时间。为了克服这个问题，您可以将`timedelta`对象添加到`datetime`对象中，然后使用`time()`方法从它们中提取时间。您在*步骤 10* 和*步骤 11* 中执行此操作。

## 还有更多

该配方中显示的对`date`和`time`对象的操作同样可以在`datetime`对象上执行。除了`+`、`-`、`<`和`>`之外，您还可以对`datetime`、`date`和`time`对象使用以下运算符:

| `>=` | 仅当第一个操作数的前面有一个`datetime` / `date` / `time`或等于第一个操作数的值时，才返回`True` |
| `<=` | 仅当第一个操作数的`datetime` / `date` / `time`大于或等于第一个操作数的`datetime`/`time`时，返回`True` |
| `==` | 仅当第一个操作数的`datetime` / `date` / `time`等于第一个操作数的值时，才返回`True` |

这不是允许的操作符的详尽列表。更多信息请参考`datetime`模块的官方文档:[https://docs.python.org/3.8/library/datetime.html](https://docs.python.org/3.8/library/datetime.html)。

# 修改日期时间对象

通常，您可能想要修改现有的`datetime`对象来表示不同的日期和时间。这个菜谱包括演示这一点的代码。

## 怎么做…

按照以下步骤执行该配方:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime
```

2.  获取当前时间戳。将其分配给`dt1`并打印:

```
>>> dt1 = datetime.now()
>>> print(dt1)
```

我们得到以下输出。您的输出会有所不同:

```
2020-08-12 20:55:46.753899
```

3.  通过替换`dt1`的`year`、`month`和`day`属性，创建一个新的`datetime`对象。分配给`dt2`并打印:

```
>>> dt2 = dt1.replace(year=2021, month=1, day=1)
>>> print(f'A timestamp from 1st January 2021: {dt2}')
```

我们得到以下输出。您的输出会有所不同:

```
A timestamp from 1st January 2021: 2021-01-01 20:55:46.753899
```

4.  通过直接指定所有属性来创建一个新的`datetime`对象。将其分配给`dt3`并打印:

```
>>> dt3 = datetime(year=2021, 
                   month=1, 
                   day=1,
                   hour=dt1.hour,
                   minute=dt1.minute, 
                   second=dt1.second, 
                   microsecond=dt1.microsecond, 
                   tzinfo=dt1.tzinfo)
print(f'A timestamp from 1st January 2021: {dt3}')
```

我们得到以下输出。您的输出会有所不同:

```
A timestamp from 1st January 2021: 2021-01-01 20:55:46.753899
```

5.  比较`dt2`和`dt3`:

```
>>> dt2 == dt3
```

我们得到以下输出。

```
True
```

## 它是如何工作的...

在*步骤 1* 中，您从`datetime`模块导入`datetime`类。在*步骤 2* 中，您使用`datetime`的`now()`方法获取当前时间戳，并将其分配给一个新属性`dt1`。要从现有的`datetime`对象中获取修改后的时间戳，可以使用`replace()`方法。在*步骤 3* 中，通过调用`replace()`方法，从`dt1`创建一个新的`datetime`对象`dt2`。您指定要修改的属性，即`year`、`month`和`day`。其余属性保持不变，它们是一个`hour`、`minute`、`second`、`microsecond`和`timezone`。您可以通过比较*步骤 2* 和*步骤 3* 的输出来确认这一点。在*步骤 4* 中，创建另一个`datetime`对象`dt3`。这次你直接调用`datetime`构造函数。您将所有属性传递给构造函数，以便创建的时间戳与`dt2`相同。在*步骤 5* 中，您通过使用返回`True`的`==`操作符来确认`dt2`和`dt3`持有完全相同的时间戳。

# 将日期时间对象转换为字符串

这个方法演示了将`datetime`对象转换成字符串，这在打印和日志记录中有应用。此外，在通过 web APIs 将时间戳作为 JSON 数据发送时，这也很有帮助。

## 怎么做…

为此配方执行以下步骤:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime
```

2.  获取当前时间戳和时区信息。将其分配给`now`并打印:

```
>>> now = datetime.now().astimezone()
```

3.  将`now`转换成一个字符串并打印出来:

```
>>> print(str(now))
```

我们得到以下输出。您的输出可能有所不同:

```
2020-08-12 20:55:48.366130+05:30
```

4.  使用`strftime()`将`now`转换为特定日期时间格式的字符串并打印出来:

```
>>> print(now.strftime("%d-%m-%Y %H:%M:%S %Z"))
```

我们得到以下输出。您的输出可能有所不同:

```
12-08-2020 20:55:48 +0530
```

## 它是如何工作的...

在*步骤 1* 中，您从`datetime`模块导入`datetime`类。在*步骤 2* 中，您获取带有时区的当前时间戳，并将其分配给一个新属性`now`。`datetime`的`now()`方法获取当前时间戳，但是没有时区信息。这样的对象称为时区本地`datetime`对象。`astimezone()`方法将来自系统本地时间的时区信息添加到这个不区分时区的对象上，实际上是将它转换成一个时区感知对象。(更多信息见*日期时间对象和时区*配方)。在*步骤 3* 中，您将`now`转换为一个字符串对象并打印它。请注意，输出日期格式是固定的，可能不是您所选择的。datetime 模块有一个`strftime()`方法，可以根据需要将对象转换成特定格式的字符串。在*步骤 4* 中，您将`now`转换成格式为`DD-MM-YYYY HH:MM:SS +Z`的字符串。*步骤 4* 中使用的指令描述如下:

| **指令** | **意为** |
| `%d` | 一个月中的某一天，以零填充的十进制数表示 |
| `%m` | 以零填充的十进制数表示的月份 |
| `%Y` | 以世纪为小数的年份 |
| `%H` | 以零填充的十进制数表示的小时(24 小时制) |
| `%M` | 以零填充的十进制数表示的分钟 |
| `%S` | 第二个是以零填充的十进制数 |
| `%Z` | 时区名称(如果对象是简单的，则为空字符串) |

可以给`.strptime()`的指令的完整列表可以在[https://docs . python . org/3.7/library/datetime . html # strftime-and-strptime-behavior](https://docs.python.org/3.7/library/datetime.html#strftime-and-strptime-behavior)找到。

# 从字符串创建日期时间对象

这个方法演示了如何将格式良好的字符串转换成`datetime`对象。这在从文件中读取时间戳方面找到了应用。此外，当通过 web APIs 以 JSON 数据的形式接收时间戳时，这也很有帮助。

## 怎么做…

为此配方执行以下步骤:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime
```

2.  用日期、时间和时区创建时间戳的字符串表示。将其分配给`now_str`:

```
>>> now_str = '13-1-2021 15:53:39 +05:30'
```

3.  将`now_str`转换为`now`，一个`datetime.datetime`对象。打印它:

```
>>> now = datetime.strptime(now_str, "%d-%m-%Y %H:%M:%S %z")
>>> print(now)
```

我们得到以下输出:

```
2021-01-13 15:53:39+05:30
```

4.  确认现在是`datetime`类型:

```
>>> print(type(now))
```

我们得到以下输出:

```
<class 'datetime.datetime'>
```

## 它是如何工作的...

在*步骤 1* 中，您从`datetime`模块导入`datetime`类。在*步骤 2* 中，您创建了一个包含有效时间戳的字符串，并将其分配给一个新属性`now_str`。`datetime`模块有一个`strptime()`方法，可以将包含特定格式的有效时间戳的字符串转换为`datetime`对象。在*步骤 3* 中，您将格式为`DD-MM-YYYY HH:MM:SS +Z`的字符串`now_str`转换为`now`。在*步骤 4* 中，您确认`now`确实是一个`datetime`类型的对象。在*步骤 3* 中使用的指令与*将日期时间对象转换成字符串*配方中描述的指令相同。

## 还有更多

当将一个字符串读入一个`datetime`对象时，整个字符串应该被适当的指令使用。部分使用字符串将引发异常，如下面的代码片段所示。错误消息显示了哪些数据没有被转换，并可用于修复提供给`strptime()`方法的指令。

尝试使用`strptime()`方法将`now_str`转换为`datetime`对象。仅使用字符串的日期部分的指令传递字符串。请注意错误:

```
>>> now = datetime.strptime(now_str, "%d-%m-%Y")
```

输出如下所示:

```
# Note: It's expected to have an error below
---------------------------------------------------------------------------
ValueError Traceback (most recent call last)
<ipython-input-96-dc92a0358ed8> in <module>
----> 1 now = datetime.strptime(now_str, "%d-%m-%Y")
      2 # Note: It's expected to get an error below

/usr/lib/python3.8/_strptime.py in _strptime_datetime(cls, data_string, format)
    566 """Return a class cls instance based on the input string and the
    567 format string."""
--> 568 tt, fraction, gmtoff_fraction = _strptime(data_string, format)
    569 tzname, gmtoff = tt[-2:]
    570 args = tt[:6] + (fraction,)

/usr/lib/python3.8/_strptime.py in _strptime(data_string, format)
    350 (data_string, format))
    351 if len(data_string) != found.end():
--> 352 raise ValueError("unconverted data remains: %s" %
    353 data_string[found.end():])
    354 

ValueError: unconverted data remains: 15:53:39 +05:30
```

# 日期时间对象和时区

有两种类型的`datetime`对象——不区分时区的和区分时区的。时区无关对象不保存时区信息，时区相关对象保存时区信息。这个方法演示了对`datetime`对象的多个时区相关操作:创建时区相关对象和时区感知对象，向时区感知对象添加时区信息，从时区相关对象中删除时区信息，以及比较时区相关对象和时区感知对象。

## 怎么做…

为此配方执行以下步骤:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime
```

2.  创建一个时区无关的`datetime`对象。将其分配给`now_tz_naive`并打印:

```
>>> now_tz_unaware = datetime.now()
>>> print(now_tz_unaware)
```

我们得到以下输出。您的输出可能有所不同:

```
2020-08-12 20:55:50.598800
```

3.  打印`now_tz_naive`的时区信息。注意输出:

```
>>> print(now_tz_unaware.tzinfo)
```

我们得到以下输出:

```
None
```

4.  创建一个支持时区的`datetime`对象。将其分配给`now_tz_aware`并打印:

```
>>> now_tz_aware = datetime.now().astimezone()
>>> print(now_tz_aware)
```

我们得到以下输出。您的输出可能有所不同:

```
2020-08-12 20:55:51.004671+05:30
```

5.  打印`now_tz_aware`的时区信息。注意输出:

```
>>> print(now_tz_aware.tzinfo)
```

我们得到以下输出。您的输出可能有所不同:

```
IST
```

6.  通过从`now_tz_aware`向`now_tz_naive`添加时区信息来创建新的时间戳。分配给`new_tz_aware`并打印:

```
>>> new_tz_aware = now_tz_naive.replace(tzinfo=now_tz_aware.tzinfo)
>>> print(new_tz_aware)
```

输出如下。您的输出可能有所不同:

```
2020-08-12 20:55:50.598800+05:30
```

7.  使用`tzinfo`属性打印`new_tz_aware`的时区信息。注意输出:

```
>>> print(new_tz_aware.tzinfo)
```

输出如下。您的输出可能有所不同:

```
IST
```

8.  通过从`new_tz_aware`中移除时区信息来创建新的时间戳。将其分配给`new_tz_naive`并打印:

```
>>> new_tz_naive = new_tz_aware.replace(tzinfo=None)
>>> print(new_tz_naive)
```

输出如下。您的输出可能有所不同:

```
2020-08-12 20:55:50.598800
```

9.  使用`tzinfo`属性打印`new_tz_naive`的时区信息。注意输出:

```
>>> print(new_tz_naive.tzinfo)
```

输出如下所示:

```
None
```

## 它是如何工作的...

在*步骤 1* 中，您从`datetime`模块导入`datetime`类。在*步骤 2* 中，您使用`now()`方法创建一个时区无关的`datetime`对象，并将其分配给一个新属性`now_tz_naive`。在*步骤 3* 中，使用`tzinfo`属性打印`now_tz_naive`保存的时区信息。注意到输出是`None`，因为这是一个时区无关的对象。

在*步骤 4* 中，您使用`now()`和`astimezone()`方法创建一个时区感知的`datetime`对象，并将其分配给一个新属性`now_tz_aware`。在*步骤 5* 中，使用`tzinfo`属性打印`now_tz_aware`持有的时区信息。观察输出是`IST`而不是`None`；因为这是一个时区感知对象。

在`step 6`中，您通过向`now_tz_naive`添加时区信息来创建一个新的`datetime`对象。时区信息取自`now_tz_aware`。使用`replace()`方法可以做到这一点(更多信息请参考*修改日期时间对象*方法)。你把它赋给一个新变量`new_tz_aware`。在*步骤 7* 中，打印`new_tz_aware`保存的时区信息。注意它与*步骤 5* 中的输出相同，因为您已经从`now_tz_aware`获取了时区信息。类似地，在*步骤 8* 和*步骤 9* 中，您创建了一个新的`datetime`对象`new_tz_naive`，但是这次您删除了时区信息。

## 还有更多

只能在不区分时区或区分时区的`datetime`对象之间使用比较运算符。不能将时区无关的`datetime`对象与时区相关的`datetime`对象进行比较。这样做会引发异常。这将在以下步骤中演示:

1.  比较两个非时区对象，`new_tz_naive`和`now_tz_naive`。注意输出:

```
>>> new_tz_naive <= now_tz_naive
```

2.  比较双时区感知对象`new_tz_aware`和`now_tz_aware`。注意输出:

```
>>> new_tz_aware <= now_tz_aware
```

我们得到以下输出:

```
True
```

3.  比较支持时区的对象和不支持时区的对象，`new_tz_aware`和`now_tz_naive`。请注意错误:

```
>>> new_tz_aware > now_tz_naive
```

我们得到以下输出:

```
-------------------------------------------------------------------
            TypeError Traceback (most recent call last)
<ipython-input-167-a9433bb51293> in <module>
----> 1 new_tz_aware > now_tz_naive
      2 # Note: It's expected to get an error below

TypeError: can't compare offset-naive and offset-aware datetimes
```

# 创造一只 Pandas。数据帧对象

现在我们已经处理完日期和时间，让我们继续处理时间序列数据。`pandas`库有一个`pandas.DataFrame`类，对于处理和操作这类数据很有用。这个方法从创建这些对象开始。

## 怎么做...

为此配方执行以下步骤:

1.  从 Python 标准库中导入必要的模块:

```
>>> from datetime import datetime
>>> import pandas
```

2.  创建一个示例时间序列数据作为字典对象列表。将其分配给`time_series`数据:

```
>>> time_series_data = \
[{'date': datetime.datetime(2019, 11, 13, 9, 0),   
  'open': 71.8075, 'high': 71.845,  'low': 71.7775, 
  'close': 71.7925, 'volume': 219512},
{'date': datetime.datetime(2019, 11, 13, 9, 15),  
 'open': 71.7925, 'high': 71.8,    'low': 71.78,   
 'close': 71.7925, 'volume': 59252},
{'date': datetime.datetime(2019, 11, 13, 9, 30),  
 'open': 71.7925, 'high': 71.8125, 'low': 71.76,
 'close': 71.7625, 'volume': 57187},
{'date': datetime.datetime(2019, 11, 13, 9, 45),  
 'open': 71.76,   'high': 71.765,  'low': 71.735,  
 'close': 71.7425, 'volume': 43048}, 
{'date': datetime.datetime(2019, 11, 13, 10, 0),  
 'open': 71.7425, 'high': 71.78,   'low': 71.7425, 
 'close': 71.7775, 'volume': 45863},
{'date': datetime.datetime(2019, 11, 13, 10, 15), 
 'open': 71.775,  'high': 71.8225, 'low': 71.77,   
 'close': 71.815,  'volume': 42460},
{'date': datetime.datetime(2019, 11, 13, 10, 30), 
 'open': 71.815,  'high': 71.83,   'low': 71.7775, 
 'close': 71.78,   'volume': 62403},
{'date': datetime.datetime(2019, 11, 13, 10, 45), 
 'open': 71.775,  'high': 71.7875, 'low': 71.7475,
 'close': 71.7525, 'volume': 34090},
{'date': datetime.datetime(2019, 11, 13, 11, 0),  
 'open': 71.7525, 'high': 71.7825, 'low': 71.7475,
 'close': 71.7625, 'volume': 39320},
{'date': datetime.datetime(2019, 11, 13, 11, 15), 
 'open': 71.7625, 'high': 71.7925, 'low': 71.76,
 'close': 71.7875, 'volume': 20190}]
```

3.  从`time_series_data`创建一个新的`DataFrame`。分配给`df`并打印:

```
>>> df = pandas.DataFrame(time_series_data)
>>> df
```

我们得到以下输出:

```
                 date    open    high     low   close volume
0 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

4.  获取`df`中的列列表:

```
>>> df.columns.tolist()
```

我们得到以下输出:

```
['date', 'open', 'high', 'low', 'close', 'volume']
```

5.  使用`time_series_data`再次创建一个`DataFrame`对象。这一次，按照您想要的顺序指定列:

```
>>> pandas.DataFrame(time_series_data, 
         columns=['close','date', 'open', 'high', 'low', 'volume'])
```

我们得到以下输出:

```
    close                date    open    high     low volume
0 71.7925 2019-11-13 09:00:00 71.8075 71.8450 71.7775 219512
1 71.7925 2019-11-13 09:15:00 71.7925 71.8000 71.7800  59252
2 71.7625 2019-11-13 09:30:00 71.7925 71.8125 71.7600  57187
3 71.7425 2019-11-13 09:45:00 71.7600 71.7650 71.7350  43048
4 71.7775 2019-11-13 10:00:00 71.7425 71.7800 71.7425  45863
5 71.8150 2019-11-13 10:15:00 71.7750 71.8225 71.7700  42460
6 71.7800 2019-11-13 10:30:00 71.8150 71.8300 71.7775  62403
7 71.7525 2019-11-13 10:45:00 71.7750 71.7875 71.7475  34090
8 71.7625 2019-11-13 11:00:00 71.7525 71.7825 71.7475  39320
9 71.7875 2019-11-13 11:15:00 71.7625 71.7925 71.7600  20190
```

## 它是如何工作的...

在*步骤 1* 中，从`datetime`模块和`pandas`包中导入`datetime`类。在*步骤 2* 中，您创建了一个时间序列数据，该数据通常由第三方历史数据 API 返回。这个数据是一个字典列表，每个字典都有相同的一组键— `date`、`open`、`high`、`low`、`close`和`volume`。注意到`date`键的值是一个`datetime`对象，其他键的值是`float`对象。

在*步骤 3* 中，通过直接调用带有`time_series_data`作为参数的构造函数来创建一个 Pandas`DataFrame`对象，并将返回数据赋给`df`。字典的键成为`df`的列名，值成为数据。在*步骤 4* 中，使用`columns`属性和`tolist()`方法将`df`的列作为一个列表取出。您可以验证列名是否与`time_series_data`中字典的键相同。

在*步骤 5* 中，通过将一个`columns`参数作为字符串列表传递给具有所需顺序的构造函数，创建一个具有特定顺序的列的`DataFrame`。

## 还有更多

当一个`DataFrame`对象被创建时，一个索引被自动分配给它，这是所有行的地址。上例中最左边的列是索引列。默认情况下，索引从`0`开始。可以通过将一个`index`参数传递给`DataFrame`构造函数来设置自定义索引，并将所需的索引作为迭代器。这显示如下:

1.  从`time_series_data`创建一个新的 DataFrame 对象，带有自定义索引:

```
>>> pandas.DataFrame(time_series_data, index=range(10, 20)) 
```

我们得到以下输出:

```
                  date    open    high     low   close volume
10 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
11 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
12 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
13 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
14 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
15 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
16 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
17 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
18 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
19 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

注意，输出中的索引从`10`开始，一直到`19`。默认索引值的范围是从`0`到`9`。

# 数据帧操作—重命名、重新排列、反转和切片

创建一个`DataFrame`对象后，可以对其执行各种操作。该配方涵盖了对`DataFrame`对象的以下操作。重命名列、重新排列列、反转`DataFrame`，并对`DataFrame`进行切片以提取行、列和数据子集。

## 做好准备

确保`df`对象在您的 Python 名称空间中可用。参考*创建 Pandas。DataFrame 对象*本章的菜谱来设置这个对象。

## 怎么做…

为此配方执行以下步骤:

1.  将`df`的`date`列重命名为`timestamp`。打印它:

```
>>> df.rename(columns={'date':'timestamp'}, inplace=True)
>>> df
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
0 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

2.  通过重新排列`df`中的列来创建一个新的`DataFrame`对象:

```
>>> df.reindex(columns=[
               'volume', 
               'close', 
               'timestamp', 
               'high', 
               'open', 
               'low'
            ])
```

我们得到以下输出:

```
  volume   close           timestamp    high    open     low
0 219512 71.7925 2019-11-13 09:00:00 71.8450 71.8075 71.7775
1  59252 71.7925 2019-11-13 09:15:00 71.8000 71.7925 71.7800
2  57187 71.7625 2019-11-13 09:30:00 71.8125 71.7925 71.7600
3  43048 71.7425 2019-11-13 09:45:00 71.7650 71.7600 71.7350
4  45863 71.7775 2019-11-13 10:00:00 71.7800 71.7425 71.7425
5  42460 71.8150 2019-11-13 10:15:00 71.8225 71.7750 71.7700
6  62403 71.7800 2019-11-13 10:30:00 71.8300 71.8150 71.7775
7  34090 71.7525 2019-11-13 10:45:00 71.7875 71.7750 71.7475
8  39320 71.7625 2019-11-13 11:00:00 71.7825 71.7525 71.7475
9  20190 71.7875 2019-11-13 11:15:00 71.7925 71.7625 71.7600
```

3.  通过反转`df`中的行创建一个新的`DataFrame`对象:

```
>>> df[::-1]
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
9 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
8 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
7 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
6 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
5 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
4 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
3 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
2 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
1 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
0 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
```

4.  从`df`中提取`close`列:

```
>>> df['close']
```

我们得到以下输出:

```
0    71.7925
1    71.7925
2    71.7625
3    71.7425
4    71.7775
5    71.8150
6    71.7800
7    71.7525
8    71.7625
9    71.7875
Name: close, dtype: float64
```

5.  从`df`中提取第一行:

```
>>> df.iloc[0]
```

我们得到以下输出:

```
timestamp    2019-11-13 09:00:00
open                     71.8075
high                      71.845
low                      71.7775
close                    71.7925
volume                    219512
Name: 10, dtype: object
```

6.  仅用前两行和前两列提取一个 *2 × 2* 矩阵:

```
>>> df.iloc[:2, :2]
```

我们得到以下输出:

```
            timestamp    open
0 2019-11-13 09:00:00 71.8075
1 2019-11-13 09:15:00 71.7925
```

## 它是如何工作的...

**重命名**:在*步骤 1* 中，使用 Pandas`DataFrame`的`rename()`方法将`date`列重命名为`timestamp`。您将`columns`参数作为一个字典来传递，将被替换的现有名称作为键，新名称作为相应的值。您还将参数`inplace`作为`True`传递，以便直接修改`df`。如果没有通过，默认值是`False`，这意味着将创建一个新的`DataFrame`，而不是修改`df`。

**重新排列**:在*步骤 2* 中，您使用`reindex()`方法通过重新排列`df`的列来创建一个新的`DataFrame`。您传递带有列名列表的`columns`参数，列名以字符串的形式按要求的顺序排列。

**反转**:在*步骤 3* 中，你通过使用索引操作符以一种特殊的方式`- [::-1]`从`df`创建一个新的`DataFrame`，它的行被反转。这类似于我们反转常规 Python 列表的方式。

**切片**:在*步骤 4* 中，使用`df`上的索引操作符提取列`close`。您传递列名`close`，作为这里的索引。返回的数据是一个`pandas.Series`对象。您可以使用 DataFrame 对象上的`iloc`属性来提取 DataFrame 对象的行、列或子集。在*步骤 5* 中，使用`iloc`提取第一行，并将`0`作为索引。返回的数据是一个`pandas.Series`对象。在*步骤 6* 中，您使用`iloc`从 df 中提取一个 2x2 子集，并将`(:2, :2)`作为索引。这意味着将提取索引 2 之前的行(0 和 1)和索引 2 之前的列(也是 0 和 1)中的所有数据。返回的数据是一个`pandas.DataFrame`对象。

对于本配方中显示的所有操作，其中新的`DataFrame`对象被返回，原始的`DataFrame`对象保持不变。

## 还有更多

属性也可以用来从一个`DataFrame`中提取一列。这显示在下面的代码中。

从`df`中提取第 4 列。观察输出:

```
>>> df.iloc[:, 4]
```

我们得到以下输出:

```
0    71.7925
1    71.7925
2    71.7625
3    71.7425
4    71.7775
5    71.8150
6    71.7800
7    71.7525
8    71.7625
9    71.7875
Name: close, dtype: float64
```

注意，该输出和*步骤 4* 的输出是相同的。

# 数据帧操作—应用、排序、迭代和连接

除了前面的配方之外，这个配方还演示了更多可以在`DataFrame`对象上执行的操作:对一列中的所有元素应用一个函数，基于一列进行排序，对行进行迭代，以及垂直和水平地连接多个`DataFrame`对象。

## 做好准备

在尝试这个食谱之前，确保你已经遵循了前一个食谱。确保您的 Python 名称空间中有来自上一个配方的`df`。

## 怎么做…

为此配方执行以下步骤:

1.  导入必要的模块

```
>>> import random
>>> import pandas
```

2.  用不同的日期和时间格式`DD-MM-YYYY HH:MM:SS`修改`df`的时间戳列中的值:

```
>>> df['timestamp'] = df['timestamp'].apply(
                        lambda x: x.strftime("%d-%m-%Y %H:%M:%S"))
>>> df
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
0 13-11-2019 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 13-11-2019 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2 13-11-2019 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3 13-11-2019 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4 13-11-2019 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5 13-11-2019 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6 13-11-2019 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7 13-11-2019 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8 13-11-2019 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9 13-11-2019 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

3.  通过对`close`列进行升序排序，创建一个新的`DataFrame`对象:

```
>>> df.sort_values(by='close', ascending=True)
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
3 13-11-2019 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
7 13-11-2019 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
2 13-11-2019 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
8 13-11-2019 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
4 13-11-2019 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
6 13-11-2019 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
9 13-11-2019 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
0 13-11-2019 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 13-11-2019 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
5 13-11-2019 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
```

4.  通过按降序对`open`列进行排序来创建一个新的`DataFrame`对象:

```
>>> df.sort_values(by='open', ascending=False)
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
6 13-11-2019 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
0 13-11-2019 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
2 13-11-2019 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
1 13-11-2019 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
7 13-11-2019 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
5 13-11-2019 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
9 13-11-2019 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
3 13-11-2019 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
8 13-11-2019 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
4 13-11-2019 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
```

5.  迭代`df`以找到每行的`open`、`close`、`high`和`low`值的平均值:

```
>>> for _, row in df.iterrows():
       avg = (row['open'] + row['close'] + row['high'] + 
              row['low'])/4
       print(f"Index: {_} | Average: {avg}")
```

我们得到以下输出:

```
Index: 0 | Average: 71.805625
Index: 1 | Average: 71.79124999999999
Index: 2 | Average: 71.781875
Index: 3 | Average: 71.750625
Index: 4 | Average: 71.760625
Index: 5 | Average: 71.795625
Index: 6 | Average: 71.800625
Index: 7 | Average: 71.765625
Index: 8 | Average: 71.76124999999999
Index: 9 | Average: 71.775625
```

6.  逐列迭代第一行`df`的所有值:

```
>>> for value in df.iloc[0]:
        print(value)
```

我们得到以下输出:

```
13-11-2019 09:00:00
71.8075
71.845
71.7775
71.7925
219512
```

7.  创建一个示例时间序列数据作为字典对象列表。将其分配给`df_new`:

```
>>> df_new = pandas. DataFrame([
    {'timestamp': datetime.datetime(2019, 11, 13, 11, 30),
     'open': 71.7875,
     'high': 71.8075,
     'low': 71.77,
     'close': 71.7925,
     'volume': 18655},
    {'timestamp': datetime.datetime(2019, 11, 13, 11, 45),
     'open': 71.7925,
     'high': 71.805,
     'low': 71.7625,
     'close': 71.7625,
     'volume': 25648},
    {'timestamp': datetime.datetime(2019, 11, 13, 12, 0),
     'open': 71.7625,
     'high': 71.805,
     'low': 71.75,
     'close': 71.785,
     'volume': 37300},
    {'timestamp': datetime.datetime(2019, 11, 13, 12, 15),
     'open': 71.785,
     'high': 71.7925,
     'low': 71.7575,
     'close': 71.7775,
     'volume': 15431},
    {'timestamp': datetime.datetime(2019, 11, 13, 12, 30),
     'open': 71.7775,
     'high': 71.795,
     'low': 71.7725,
     'close': 71.79,
     'volume': 5178}])
>>> df_new
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
0 2019-11-13 11:30:00 71.7875 71.8075 71.7700 71.7925  18655
1 2019-11-13 11:45:00 71.7925 71.8050 71.7625 71.7625  25648
2 2019-11-13 12:00:00 71.7625 71.8050 71.7500 71.7850  37300
3 2019-11-13 12:15:00 71.7850 71.7925 71.7575 71.7775  15431
4 2019-11-13 12:30:00 71.7775 71.7950 71.7725 71.7900   5178
```

8.  通过垂直连接`df`和`df_new`创建一个新的数据帧:

```
>>> pandas.concat([df, df_new]).reset_index(drop=True)
```

我们得到以下输出:

```
             timestamp    open    high     low   close volume
0  13-11-2019 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1  13-11-2019 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2  13-11-2019 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3  13-11-2019 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4  13-11-2019 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5  13-11-2019 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6  13-11-2019 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7  13-11-2019 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8  13-11-2019 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9  13-11-2019 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
10 2019-11-13 11:30:00 71.7875 71.8075 71.7700 71.7925  18655
11 2019-11-13 11:45:00 71.7925 71.8050 71.7625 71.7625  25648
12 2019-11-13 12:00:00 71.7625 71.8050 71.7500 71.7850  37300
13 2019-11-13 12:15:00 71.7850 71.7925 71.7575 71.7775  15431
14 2019-11-13 12:30:00 71.7775 71.7950 71.7725 71.7900   5178
```

## 它是如何工作的...

在*步骤 1* 中，您导入`pandas`包。

**应用**:在*步骤 2* 中，使用`apply`方法修改`df`的`timestamp`列中的所有值。该方法将一个函数作为要应用的输入。您在这里传递一个 lambda 函数，它期望一个`datetime`对象作为单个输入，并使用`strftime()`将其转换为所需格式的字符串。(有关`strftime()`的更多详细信息，请参考*将日期时间对象转换为字符串*配方)。在`df`的`timestamp`列上调用`apply`方法，它是一个`pandas.Series`对象。lambda 函数应用于列中的每个值。这个调用返回一个新的`pandas.Series`对象，您将它分配回`df`的`timestamp`列。注意，在此之后，`df`的`timestamp`列将时间戳保存为字符串对象，而不是之前的`datetime`对象。

**排序**:在*步骤 3* 中，您通过对`df`的`close`列进行升序排序来创建一个新的`DataFrame`对象。您使用`sort_values()`方法来执行排序。类似地，在*步骤 4* 中，您通过对`df`的`open`列进行降序排序来创建一个新的`DataFrame`对象。

**迭代**:在*步骤 5* 中，使用`iterrows()`方法迭代 df，以找到并打印每行的`open`、`close`、`high`和`low`值的平均值。`iterrows()`方法以(`index, pandas.Series`)对的形式遍历每一行。在*步骤 6* 中，使用`df.iloc[0]`迭代`df`第一行的所有值。您得到第一行的`timestamp`、`open`、`high`、`low`、`close`和`volume`列值作为输出。

**串联**:在*步骤 6* 中，你创建一个新的`DataFrame`，类似于*创建 Pandas 的*步骤 2* 中创建的那个。DataFrame 对象* recipe，并将其分配给`df_new`。您使用`pandas.concat()`函数通过垂直连接`dt`和`df_new`来创建一个新的`DataFrame`。这意味着一个新的`DataFrame`将被创建，其中`df_new`的行被附加到`df`的行下面。您将包含`df`和`df_new`的列表作为参数传递给`pandas.concat()`函数。此外，要从`0`开始创建一个新的索引，可以使用`reset_index()`方法，将参数 drop 作为`True`传递。如果不使用`reset_index()`，串联的`DataFrame`的索引将类似于`0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4`。(参见*创造一只 Pandas。DataFrame 对象*配方，了解更多关于`DataFrame`索引的信息。)

## 还有更多

您还可以使用`pandas.concat()`函数将两个`DataFrame`对象水平连接在一起，这是按列的方式，将`axis`参数的值`1`传递给`pandas.concat()`方法。这显示在以下步骤中:

1.  从 Python 标准库中导入`random`模块:

```
>>> import random
```

2.  使用单列、`open`和随机值创建 DataFrame 对象。将其分配给`df1`并打印:

```
>>> df1 = pandas.DataFrame([random.randint(1,100) for i in 
                            range(10)], columns=['open'])
>>> df1
```

我们得到以下输出。您的输出可能有所不同:

```
   open
0    99
1    73
2    16
3    53
4    47
5    74
6    21
7    22
8     2
9    30
```

3.  用单列、`close`和随机值创建另一个`DataFrame`对象。分配给`df2`并打印:

```
>>> df2 = pandas.DataFrame([random.randint(1,100) for i in 
                            range(10)], columns=['close'])
>>> df2
```

我们得到以下输出:

```
   close
0     63
1     84
2     44
3     56
4     25
5      1
6     41
7     55
8     93
9     82
```

4.  通过水平连接`df1`和`df2`创建一个新的`DataFrame`

```
>>> pandas.concat([df1, df2], axis=1)
```

我们得到以下输出。您的输出可能有所不同:

```
    open  close
0     99     93
1     73     42
2     16     57
3     53     56
4     47     25
5     74      1
6     21     41
7     22     55
8      2     93
9     30     82
```

# 将数据帧转换成其他格式

这个菜谱演示了将`DataFrame`对象转换成其他格式，比如`.csv`文件、`json`对象和`pickle`对象。转换成`.csv`文件使得使用电子表格应用程序进一步处理数据变得更加容易。`json`格式对于通过 web APIs 传输`DataFrame`对象很有用。`pickle`格式对于通过套接字将在一个 Python 会话中创建的`DataFrame`对象传输到另一个 Python 会话非常有用，而不必重新创建它们。

## 做好准备

确保对象`df`在您的 Python 名称空间中可用。参考*创建 Pandas。DataFrame 对象*本章的菜谱来设置这个对象。

## 怎么做…

为此配方执行以下步骤:

1.  将`df`转换并保存为 CSV 文件:

```
>>> df.to_csv('dataframe.csv', index=False)
```

2.  将`df`转换成 JSON 字符串:

```
>>> df.to_json()
```

我们得到以下输出:

```
'{
    "timestamp":{
        "0":"13-11-2019 09:00:00","1":"13-11-2019 09:15:00",
        "2":"13-11-2019 09:30:00","3":"13-11-2019 09:45:00",
        "4":"13-11-2019 10:00:00","5":"13-11-2019 10:15:00",
        "6":"13-11-2019 10:30:00","7":"13-11-2019 10:45:00",
        "8":"13-11-2019 11:00:00","9":"13-11-2019 11:15:00"},
    "open":{
        "0":71.8075,"1":71.7925,"2":71.7925, "3":71.76,         
        "4":71.7425,"5":71.775,"6":71.815, "7":71.775,
        "8":71.7525,"9":71.7625},
    "high"{
        "0":71.845,"1":71.8,"2":71.8125,"3":71.765,
        "4":71.78,"5":71.8225,"6":71.83,"7":71.7875,
        "8":71.7825,"9":71.7925},
    "low":{
        "0":71.7775,"1":71.78,"2":71.76,"3":71.735,
        "4":71.7425,"5":71.77,"6":71.7775,"7":71.7475,
        "8":71.7475,"9":71.76},
    "close":{
        "0":71.7925,"1":71.7925,"2":71.7625,"3":71.7425,
        "4":71.7775,"5":71.815,"6":71.78,"7":71.7525,
        "8":71.7625,"9":71.7875},
    "volume":{
        "0":219512,"1":59252,"2":57187,"3":43048,
        "4":45863,"5":42460,"6":62403,"7":34090,
        "8":39320,"9":20190}}'
```

3.  将`df`保存到文件中:

```
>>> df.to_pickle('df.pickle')
```

## 它是如何工作的...

在*步骤 1* 中，使用`to_csv()`方法将`df`保存为`.csv`文件。将生成`.csv`文件的文件路径`dataframe.csv`作为第一个参数，将索引`False`作为第二个参数。将索引作为`False`传递可以防止索引被转储到`.csv`文件中。如果想保存`DataFrame`及其索引，可以将索引作为`True`传递给`to_csv()`方法。

在*步骤 2* 中，您使用`to_json()`方法将`df`转换成 JSON 字符串。您没有向`to_json()`方法传递任何额外的参数。

在*步骤 3* 中，您使用`to_pickle()`方法来处理(序列化)对象。同样，您没有向`to_pickle()`方法传递任何额外的参数。

方法`to_csv()`、`to_json()`和`to_pickle()`可以接受比这个菜谱中显示的更多的可选参数。有关这些方法的完整信息，请参考官方文档:

*   `to_csv()`:[https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas。DataFrame.to_csv.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html)
*   `to_json()`:[https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas。DataFrame.to_json.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_json.html)
*   `to_pickle()`:[https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas。DataFrame.to_pickle.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_pickle.html)

# 从其他格式创建数据帧

在这个菜谱中，您将从其他格式创建`DataFrame`对象，例如`.csv`文件、`.json`字符串和`pickle`文件。使用电子表格应用程序创建的`.csv`文件、通过 web APIs 接收的有效 JSON 数据或者通过套接字接收的有效 pickle 对象都可以使用 Python 进行进一步处理，将它们转换为`DataFrame`对象。

加载从不受信任的来源接收的 pickled 数据可能不安全。请谨慎使用`read_pickle()`。你可以在这里找到更多的细节:【https://docs.python.org/3/library/pickle.html】T2。如果您在之前的配方中创建的泡菜文件上使用该功能，使用`read_pickle()`是绝对安全的。

## 做好准备

在开始制作这个食谱之前，请确保你已经按照前面的食谱做了。

## 怎么做…

为此配方执行以下步骤:

1.  通过读取 CSV 文件创建 DataFrame 对象:

```
>>> pandas.read_csv('dataframe.csv')
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
0 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

2.  通过读取 JSON 字符串创建 DataFrame 对象:

```
>>> pandas.read_json("""{
        "timestamp": {
            "0":"13-11-2019 09:00:00", "1":"13-11-2019 09:15:00", 
            "2":"13-11-2019 09:30:00","3":"13-11-2019 09:45:00", 
            "4":"13-11-2019 10:00:00","5":"13-11-2019 10:15:00",
            "6":"13-11-2019 10:30:00","7":"13-11-2019 10:45:00",
            "8":"13-11-2019 11:00:00","9":"13-11-2019 11:15:00"},

        "open":{
            "0":71.8075,"1":71.7925,"2":71.7925,"3":71.76,
            "4":71.7425,"5":71.775,"6":71.815,"7":71.775,
            "8":71.7525,"9":71.7625},

        "high":{
            "0":71.845,"1":71.8,"2":71.8125,"3":71.765,"4":71.78,
            "5":71.8225,"6":71.83,"7":71.7875,"8":71.7825,
            "9":71.7925},

        "low":{
            "0":71.7775,"1":71.78,"2":71.76,"3":71.735,"4":71.7425,
            "5":71.77,"6":71.7775,"7":71.7475,"8":71.7475,
            "9":71.76},

        "close":{
            "0":71.7925,"1":71.7925,"2":71.7625,"3":71.7425,
            "4":71.7775,"5":71.815,"6":71.78,"7":71.7525,
            "8":71.7625,"9":71.7875},

        "volume":{
            "0":219512,"1":59252,"2":57187,"3":43048,"4":45863,
            "5":42460,"6":62403,"7":34090,"8":39320,"9":20190}}
            """)
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
0 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

3.  通过解开`df.pickle`文件创建一个`DataFrame`对象:

```
>>> pandas.read_pickle('df.pickle')
```

我们得到以下输出:

```
            timestamp    open    high     low   close volume
0 2019-11-13 09:00:00 71.8075 71.8450 71.7775 71.7925 219512
1 2019-11-13 09:15:00 71.7925 71.8000 71.7800 71.7925  59252
2 2019-11-13 09:30:00 71.7925 71.8125 71.7600 71.7625  57187
3 2019-11-13 09:45:00 71.7600 71.7650 71.7350 71.7425  43048
4 2019-11-13 10:00:00 71.7425 71.7800 71.7425 71.7775  45863
5 2019-11-13 10:15:00 71.7750 71.8225 71.7700 71.8150  42460
6 2019-11-13 10:30:00 71.8150 71.8300 71.7775 71.7800  62403
7 2019-11-13 10:45:00 71.7750 71.7875 71.7475 71.7525  34090
8 2019-11-13 11:00:00 71.7525 71.7825 71.7475 71.7625  39320
9 2019-11-13 11:15:00 71.7625 71.7925 71.7600 71.7875  20190
```

## 它是如何工作的...

在*步骤 1* 中，您使用`pandas.read_csv()`函数从`.csv`文件创建一个 DataFrame 对象。您传递了一个参数`dataframe.csv`，即应该从哪里读取`.csv`文件的文件路径。回想一下，你已经在上一个配方的第 1 步*中创建了`dataframe.csv`。*

在*步骤 2* 中，您使用`pandas.read_json()`函数从一个有效的 JSON 字符串创建一个`DataFrame`对象。您可以将上一个菜谱中的*步骤 2* 的输出中的 JSON 字符串作为参数传递给这个函数。

在*步骤 3* 中，您使用`pandas.read_pickle()`方法从一个`pickle`文件创建一个`DataFrame`对象。您将从 pickle 文件读取的文件路径`df.pickle`作为参数传递给这个函数。回想一下，你在上一个食谱的第三步*中创造了什么`df.pickle`。*

如果您遵循前面的方法，所有三个步骤的输出都将是同一个`DataFrame`对象。这将与之前配方中的`df`相同。

方法`read_csv()`、`read_json()`和`read_pickle()`可以接受比这个菜谱中显示的更多的可选参数。有关这些方法的完整信息，请参考官方文档。

*   `read_csv()`:[https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas . read _ CSV . html # pandas . read _ CSV](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv)
*   `read_json()`:[https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas . read _ JSON . html # pandas . read _ JSON](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_json.html#pandas.read_json)
*   `read_pickle()`:[https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas . read _ pickle . html # pandas . read _ pickle](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_pickle.html#pandas.read_pickle)