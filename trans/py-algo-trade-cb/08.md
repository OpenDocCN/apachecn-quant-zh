# 算法交易策略-逐步编码

建立自己的算法交易策略是一项复杂的任务。测试和运行你的策略需要一个有很多组件的交易平台。这些组件包括计算引擎、实时数据馈送、经纪人连接、记事本、基金管理器、时钟、虚拟订单管理系统等等。

在这一章中，你将使用算法交易平台 algo bulls([https://algobulls.com](https://algobulls.com))提供的服务。这个平台提供了一个叫做`pyalgotrading`([https://github.com/algobulls/pyalgotrading](https://github.com/algobulls/pyalgotrading))的 Python 包。您将通过子类化包中提供的`StrategyBase`抽象类，将您的策略编码为 Python 类。抽象类充当模板，以最小的努力快速开发和验证新策略。您可以使用 AlgoBulls 平台对您的策略进行回溯测试、纸上交易和真实交易。`pyalgotrading`软件包帮助我们专注于制定战略，并负责与 AlgoBulls 平台进行沟通以实现执行目的。

本章介绍两种策略:

*   **EMA-常规单策略**:该策略基于技术指标指数移动平均线。它使用常规订单。
*   **MACD 套单策略**:该策略基于技术指标移动平均线收敛发散。它使用括号订单。

最初，您可能会发现策略编码是一项艰巨的任务。所以编码部分分为五个食谱。每个配方演示了一个或多个由`StrategyBase`类执行的方法。第六个配方演示了如何将策略上传到 AlgoBulls 平台。

策略的框架如下所示:

```
class MyCustomStrategy(StrategyBase):
    def __init__(self, *args, **kwargs): # [Recipes 1, 7]
        ...
    def name(): # [Recipes 1, 7]
        …
    def versions_supported(): # [Recipes 1, 7]
        ...
    def initialize(self): # [Recipes 1, 7]
        ...
    def strategy_select_instruments_for_entry(self, candle, 
                                              instruments_bucket):
        … # [Recipes 2, 8]
    def strategy_enter_position(self, candle, instrument, sideband_info):
        … # [Recipes 3, 9]
    def strategy_select_instruments_for_exit(self, candle, 
                                             instruments_bucket):
        … # [Recipes 4, 10]
    def strategy_exit_position(self, candle, instrument, sideband_info):
        … # [Recipes 5, 11]
```

AlgoBulls 核心引擎是驱动 AlgoBulls 平台的交易引擎。它负责阅读你的策略，并在回溯测试、纸上交易和真实交易中执行它们。AlgoBulls 核心引擎使用以下流程图来成功执行您的策略:

![](assets/cb26ef36-c0ba-4d61-b223-d6224f210f67.png)

在本章中，我们将介绍以下配方:

*   EMA-常规顺序策略–对 __init__、initialize、name 和 versions_supported 方法进行编码
*   EMA-常规订单策略–编码策略 _ 选择 _ 工具 _ 输入方法
*   EMA-常规订单策略–编码策略输入位置方法
*   EMA-常规订单策略–编码策略 _ 选择 _ 工具 _ 退出方法
*   EMA-常规订单策略–编码策略 _ 退出 _ 头寸方法
*   EMA-常规订单策略-将策略上传到 AlgoBulls 交易平台
*   MACD-括号-顺序策略–编码 __init__、initialize、name 和 versions_supported 方法
*   MACD 括号订单策略–编码策略 _ 选择 _ 工具 _ 输入方法
*   MACD-括号-顺序策略-编码策略 _ 输入 _ 位置方法
*   MACD 括号顺序策略–编码策略 _ 选择 _ 工具 _ 退出方法
*   MACD-括号-顺序策略-编码策略 _ 退出 _ 位置方法
*   MACD-括号-订单策略-将策略上传到 AlgoBulls 交易平台

# 技术要求

要执行本章中的配方，您需要以下内容:

*   Python 3.7+版本
*   Python 包:
*   `pyalgotrading` ( `$ pip install pyalgotrading`)
*   `pyalgostrategypool` ( `$ pip install pyalgostrategypool`)
*   `TA-Lib` ( `$ pip install TA-Lib`)

如果您在安装`TA-Lib`时遇到错误，这主要是由于缺少依赖项。您可以按照以下说明解决问题:

*   **对于 Mac OS X，使用以下**:

```
$ brew install ta-lib
```

*   **对于 Windows，使用以下说明**:

你可以根据你的 Windows build (32 位/64 位)和 Python 版本从[https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib](https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib)安装最新的`TA-Lib`二进制。因此，例如，网站上的这个链接[TA _ Lib-0 . 4 . 18 cp38 cp38 win _ amd64 . whl](https://download.lfd.uci.edu/pythonlibs/w3jqiv8s/TA_Lib-0.4.18-cp39-cp39-win_amd64.whl)，是针对`TA-Lib`版本 0.4.18 ( `TA_Lib-0.4.18`)和 Python 版本 3.8 ( `cp38`)，并且是 Windows 64 位兼容的(`win_amd64`)。

*   **对于 Linux，采取以下步骤**:

下载这个`gzip`文件—[http://pr downloads . SourceForge . net/ta-lib/ta-lib-0 . 4 . 0-src . tar . gz](http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz)—并从您的 Linux 终端运行以下命令:

1.  提取下载的包含`TA-Lib`源代码的`gzip`文件:

```
$ tar -xzf ta-lib-0.4.0-src.tar.gz
```

2.  将您当前的工作目录更改为提取的文件夹:

```
$ cd ta-lib/
```

3.  运行`configure`命令为您的机器配置`TA-Lib`:

```
$ ./configure --prefix=/usr
```

4.  运行`make`命令，从下载的源代码构建`TA-Lib`:

```
$ make
```

5.  运行`install`命令将构建的可执行文件和库安装到机器上的特定目录:

```
$ sudo make install 
```

如果这没有帮助，你仍然得到错误，请参考在[https://github.com/mrjbq7/ta-lib#dependencies](https://github.com/mrjbq7/ta-lib#dependencies)的官方`TA-Lib` GitHub 页面。本章最新的 Jupyter 笔记本可以在 GitHub 上找到，网址是[https://GitHub . com/packt publishing/Python-algorithm-Trading-Cookbook/tree/master/chapter 08](https://github.com/PacktPublishing/Python-Algorithmic-Trading-Cookbook/tree/master/Chapter08)。

以下代码将帮助您导入本章中所有食谱所使用的必要模块。在尝试任何食谱之前，请确保您已遵循此步骤:

```
>>> from pyalgotrading.strategy.strategy_base import StrategyBase
>>> from pyalgotrading.constants import *
```

在前五个食谱中，你将根据 EMA 技术指标创建一个完整的算法交易策略。这种策略称为 **EMA 常规订单**策略，描述如下:

*   **技术指标**:
*   `EMA(timeperiod=4)`或`EMA4`
*   `EMA(timeperiod=9)`或`EMA9`

虽然时间段的典型值是`4`和`9`，但这两个时间段都被作为参数，因此它们可以在运行时更改，而不必再次重新创建策略。这将在本章的第一个配方中详细讨论。

*   **订单属性**:
*   订单交易类型:`BUY`和`SELL`
*   订单类型:`Regular`
*   订单代码:`INTRADAY`
*   订单品种:`Market`
*   **策略算法**:
*   每当`EMA4`向上穿过`EMA9`时，注意以下几点:
*   先前的`SHORT`位置，如果存在，应该退出。
*   策略产生一个`BUY`信号，应输入一个新的`LONG`位置。
*   每当`EMA4`向下穿过`EMA9`时，注意以下几点:
*   先前的`LONG`位置，如果存在，应该退出。
*   策略产生一个`SELL`信号，应输入一个新的`SHORT`位置。

您将把整个逻辑编码成一个名为`StrategyEMARegularOrder`的 Python 类。这个类将是`pyalgotrading`包中`StrategyBase`的子类。在 AlgoBulls 平台上传`StrategyEMARegularOrder`后，可以对该策略进行回测(参考[第九章](09.html)、*回测策略*的前六个菜谱)、纸交易(参考[第十章](10.html)、*纸交易*的前五个菜谱)、实盘交易(参考[第十一章](11.html)、*实盘交易*的前五个菜谱)。

在第七到第十一个食谱中，你将根据 MACD 技术指标创建一个完整的算法交易策略。该策略被称为 **MACD 括号顺序**策略，描述如下:

*   **技术指标**:
*   MACD:这个技术指标有三个部分:MACD 线、MACD 信号和 MACD 柱状图。对于这种策略，我们只关心 MACD 线和 MACD 信号部分。
*   **订单属性**:
*   订单交易类型:`BUY`和`SELL`
*   订单类型:`Bracket`
*   订单代码:`INTRADAY`
*   订单品种:`Limit`
*   **策略算法**:
*   每当 MACD 线向上穿过 MACD 信号时，注意以下几点:
*   先前的`SHORT`位置，如果存在，应该退出。
*   策略产生一个`BUY`信号，应输入一个新的`LONG`位置。
*   每当 MACD 线向下穿过 MACD 信号时，注意以下几点:
*   先前的`LONG`位置，如果存在，应该退出。
*   策略产生一个`SELL`信号，应输入一个新的`SHORT`位置。

您将把整个逻辑编码成一个名为`StrategyMACDBracketOrder`的 Python 类。这个类将是`pyalgotrading`包中`StrategyBase`的子类。将`StrategyMACDBracketOrder`上传到 AlgoBulls 平台后，可以进行回测(参考[第九章](09.html)、*算法交易-回测*)、纸上交易(参考[第十章](10.html)、*算法交易-**纸上交易*)、实盘交易(参考[第十一章](11.html)、*算法交易-*【T18)

有关这些主题的更多信息，请参考以下相应章节:

*   **技术指标** : [第五章](05.html)，*计算和绘图技术指标*
*   **订单属性** : [第六章](06.html)、*交易所常规下单*和[第七章](07.html)、*交易所下单*。

您需要在 AlgoBulls 平台([https://algobulls.com](https://algobulls.com))上设置您的帐户，以获得您的 API 令牌。设立账户是免费的。根据您的使用情况，使用其服务可能会产生费用。你可以从网站上的免费包开始。详见*附录二*。

# EMA-常规顺序策略–对 __init__、initialize、name 和 versions_supported 方法进行编码

这个菜谱演示了`StrategyEMARegularOrder`类的初始编码。完整的类将在本章的*EMA-常规订单策略-编码策略 _ 退出 _ 头寸方法*方法结束时编码。在本食谱中，您将编写以下方法:

*   `__init__()`
*   `initialize()`
*   `name()`
*   `versions_supported()`

详细了解 EMA 技术指标，请参考[第五章](05.html)、*计算并绘制技术指标*的*趋势指标——指数移动平均线*配方。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`__init__()`和`initialize()`方法。

## 做好准备

确保 Python 名称空间中有`StrategyBase`和`pyalgotrading`常量。参见本章的*技术要求*部分进行设置。

## 怎么做…

创建一个名为`StrategyEMARegularOrder`的新类，它将是`StrategyBase`的子类，然后定义所需的四个方法:

```
class StrategyEMARegularOrder(StrategyBase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.timeperiod1 = self.strategy_parameters['timeperiod1']
        self.timeperiod2 = self.strategy_parameters['timeperiod2']
        self.main_order = None
    def initialize(self):
        self.main_order = {}
    @staticmethod
    def name():
        return 'EMA Regular Order Strategy'
    @staticmethod
    def versions_supported():
        return AlgoBullsEngineVersion.VERSION_3_2_0
```

## 它是如何工作的…

在这个菜谱中，我们创建了从`StrategyBase`继承而来的`StrategyEMARegularOrder`类。我们为这个类定义了四个方法，描述如下:

*   `__init__()`方法:这是你制定新战略时要做的第一件事。首先，创建这个方法，并使用`super()`调用父类`__init__()`方法。这有助于 AlgoBulls 核心引擎创建进一步发展战略所需的必要数据结构。接下来，从`self.strategy_parameters` — `self.timeperiod1`和`self.timeperiod2`创建两个新属性。`self.strategy_parameters`是一个字典对象，可用于从`StrategyBase`子类化的每个策略。([第 8 章](09.html)的第二个配方，*回溯测试策略*，讨论了这些值在运行时如何传递给`self.strategy_parameters`。)您将在下一个配方中使用这些参数作为两个 EMA 的时间段。

最后，创建一个新属性`self.main_order`，它是一个空字典。我们将使用它来保存在执行该策略期间下的所有未结订单的句柄。

*   `initialize()`方法:该方法在每个交易日开始时被调用，以将任何内部变量初始化为它们的默认状态。对于实盘交易和纸面交易，这个方法调用一次。对于多日回溯测试，这个方法被多次调用，在每个新的交易日开始时调用一次。在这个方法中，您将`self.main_order`初始化为一个空字典。
*   `name()`方法:这是一个静态方法，它返回这个策略的名称。这是在利用回溯测试、纸上交易和真实交易服务时使用的策略。在这个方法中，您只需返回一个字符串`Exponential Moving Average Regular Order`。您可以返回您选择的任何字符串。
*   `versions_supported()`方法:这个静态方法用于返回 AlgoBulls 核心引擎版本，该策略是为该版本创建的。通常，随着 AlgoBulls 核心引擎的新升级，可能会引入一些向后不兼容的更改。这种方法有助于确保该策略始终在 AlgoBulls 核心引擎的正确版本上运行。在这个方法中，您从 constants 模块返回最高可用版本，在编写本章时是 VERSION_3_2_0。

这四种方法是强制性的；它们由`StrategyBase`基类强制执行，不能被跳过。

# EMA-常规订单策略–编码策略 _ 选择 _ 工具 _ 输入方法

在这个菜谱中，您将继续编写`StrategyEMARegularOrder`类。在这里，您编写了`strategy_select_instruments_for_entry()`方法，这是一个由`StrategyBase`基类强制执行的强制方法。AlgoBulls 核心引擎在每个新蜡烛上调用这个方法，用于回溯测试、纸面交易和实际交易服务。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_select_instruments_for_entry()`方法。

## 做好准备

在开始这个配方之前，确保你已经按照前面的配方创建了`StrategyEMARegularOrder`类。

## 怎么做…

继续编写`StrategyEMARegularOrder`类的代码。我们需要定义两种新方法——一种是获取 MACD 线和 MACD 历史信号之间的交叉值的方法，另一种是根据计算的交叉值从`instruments_bucket`中选择工具进入新位置的方法:

```
class StrategyEMARegularOrder(StrategyBase):
    # Previous methods not shown
    def get_crossover_value(self, instrument):
        hist_data = self.get_historical_data(instrument)
        ema_x = talib.EMA(hist_data['close'], timeperiod=self.timeperiod1)
        ema_y = talib.EMA(hist_data['close'], timeperiod=self.timeperiod2)
        crossover_value = self.utils.crossover(ema_x, ema_y)
        return crossover_value
    def strategy_select_instruments_for_entry(self, candle,
                                              instruments_bucket):
        selected_instruments_bucket = []
        sideband_info_bucket = []
        for instrument in instruments_bucket:
            crossover_value = self.get_crossover_value(instrument)
            if crossover_value == 1:
                selected_instruments_bucket.append(instrument)
                sideband_info_bucket.append({'action': 'BUY'})
            elif crossover_value == -1:
                if self.strategy_mode is StrategyMode.INTRADAY:
                    selected_instruments_bucket.append(instrument)
                    sideband_info_bucket.append({'action': 'SELL'})
        return selected_instruments_bucket, sideband_info_bucket
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyEMARegularOrder`类。我们为此类定义了两个新方法，描述如下:

*   `get_crossover_value()`方法:该方法将`instrument`作为参数(连同`self`)。这是必须计算交叉价值的金融工具。您使用`self.get_historical_data()`方法获取最新的历史数据，并将其分配给一个新属性`hist_data`。我们将`instrument`作为参数传递给这个方法。`hist_data`属性是一个具有`timestamp`、`open`、`high`、`low`、`close`和`volume`列的`pandas.DataFrame`对象。提取的历史数据的默认持续时间是过去 15 天。

在`hist_data`收盘时，使用`talib.EMA`函数计算`self.timeperiod1`时段的均线，并将其分配给`ema_x`。这个数据是一个`pandas.Series`对象。(有关 EMA 计算的更多详细信息，请参考第五章*技术指标的计算和绘制*的[第二个配方。)类似地，在`hist_data`收盘时计算`self.timeperiod2`时段的 EMA，并将其分配给`ema_y`。这个返回数据也是一个`pandas.Series`对象。](05.html)

使用`self.utils.crossover(ema_x, ema_y)`计算`ema_x`和`ema_y`之间的交叉值，并将其分配给新属性`crossover_value`。`crossover()`函数调用的工作方式如下:

*   它接受两个可重复项作为输入。我们在这里通过`ema_x`和`ema_y`。
*   如果`ema_x`向上穿越`ema_y`，穿越函数返回`1`。
*   如果`ema_x`向下穿过`ema_y`，交叉函数返回`-1`。
*   如果`ema_x`和`ema_y`之间没有交叉，那么交叉函数返回`0`。

最后，你返回`crossover_value`。

*   `strategy_select_instruments_for_entry()`方法:这个方法有两个参数，除了`self` — `candle`，一个包含当前蜡烛线时间戳的`CandleTime`类型的对象，和一个包含所有可用于创建新头寸的金融工具的`SetInstruments`类型的对象。我们在策略执行时传递这些数据。您创建了两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。然后在`instruments_bucket`上运行一个`for`循环，对于每个乐器，调用`self.get_crossover_value()`并将其值保存到一个新属性`crossover_value`。根据`crossover_value`的值，您做出如下决定:
*   如果`crossover_value`为`1`，则表示该策略正在给出一个`BUY`信号。您需要执行以下操作:
*   将`instrument`追加到`selected_instruments_bucket`上。
*   向`sideband_info_bucket`属性追加一个`{'action': 'BUY'}`字典。
*   如果`crossover_value`为`-1`，则表示该策略正在给出一个`SELL`信号。您需要执行以下操作:
*   将`instrument`追加到`selected_instruments_bucket`上。
*   向`sideband_info_bucket`属性追加一个`{'action': 'SELL'}`字典。
*   如果`crossover_value`既不是`1`也不是`-1`，这意味着该策略没有给出任何信号。你在这里什么都不做。

最后，您返回两个属性:`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已被填充，或者可能仍为空列表。

回想一下，对每个蜡烛调用了`strategy_select_instruments_for_entry()`方法，所以对每个新的蜡烛重复前面的步骤。在合适的蜡烛里，你会得到一个`BUY`或者一个`SELL`信号，而在其他的蜡烛里，你将得不到任何信号。根据这个信号，你可以下适当的订单，这将在下一个食谱中讨论。

`strategy_select_instruments_for_entry()`方法由`StrategyBase`基类执行，必须为每个策略定义。
`get_crossover_value()`方法是一个助手方法，这意味着它不是由`StrategyBase`基类强制执行的。您可以选择不定义这个函数，或者定义多个这样的帮助函数。

# EMA-常规订单策略–编码策略输入位置方法

在这个菜谱中，您将继续编写`StrategyEMARegularOrder`类的代码。在这里，您编写了`strategy_enter_position()`方法，这是一个由`StrategyBase`基类强制执行的强制方法。每次`strategy_select_instruments_for_entry`方法返回非空数据时，AlgoBulls 核心引擎都会调用该方法。对于回溯测试、纸面交易和真实交易服务，可能不会对每个新蜡烛线都调用这个方法。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_enter_position()`方法。

## 做好准备

在开始制作这个食谱之前，确保你已经按照前面的食谱做了。

## 怎么做…

继续编写`StrategyEMARegularOrder`类的代码。我们需要定义一种方法来为给定的工具打孔新订单并输入新头寸:

```
class StrategyEMARegularOrder(StrategyBase):
    # Previous methods not shown
    def strategy_enter_position(self, candle, instrument, sideband_info):
        if sideband_info['action'] == 'BUY':
            qty = self.number_of_lots * instrument.lot_size
            self.main_order[instrument] = \
                self.broker.BuyOrderRegular(instrument=instrument,
                          order_code=BrokerOrderCodeConstants.INTRADAY,
                          order_variety=BrokerOrderVarietyConstants.MARKET,
                          quantity=qty)
        elif sideband_info['action'] == 'SELL':
            qty = self.number_of_lots * instrument.lot_size
            self.main_order[instrument] = \
                self.broker.SellOrderRegular(instrument=instrument,
                          order_code=BrokerOrderCodeConstants.INTRADAY,
                          order_variety=BrokerOrderVarietyConstants.MARKET,
                          quantity=qty)
        else:
            raise SystemExit(f'Got invalid sideband_info value: 
                              {sideband_info}')
        return self.main_order[instrument]
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyEMARegularOrder`类。我们为这个类定义了一个新方法`strategy_enter_position()`，描述如下:

*   这个方法有三个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instrument`:表示金融工具的`Instrument`类型的对象。
*   `sideband_info`:dictionary 对象，保存关于为`instrument`属性放置的交易的信息。这个物体看起来像`{'action': [action_value]}`，这里的`[action_value]`可以是`'BUY'`也可以是`'SELL'`。
*   您通过将`self.number_of_lots`乘以`instrument.lot_size`来计算订单数量，并将其分配给一个新属性`qty`。`self.number_of_lots`属性保存关于交易手数的信息，您可以在执行这个策略时传递这些信息。`instrument.lot_size`属性为`instrument`保存`lot_size`，它是一个正整数。例如，如果传递的批次数量为 2，且器械的批量大小为 10，则订单的数量为 2 * 10 = 20。
*   如果`sideband_info`是`{'action': 'BUY'}`，您通过创建一个`self.broker.BuyOrderRegular`类的实例(第 6 章的第一个配方，*在交易所*下常规订单)并将其值赋给`self.main_order[instrument]`来下一个`BUY`交易类型的`Regular`订单。
*   如果`sideband_info`是`{'action': 'SELL'}`，您通过创建一个`self.broker.SellOrderRegular`类的实例(第 6 章的第一个配方，*在交易所*下常规订单)并将其值赋给`self.main_order[instrument]`来下一个`SELL`交易类型的`Regular`订单。

在这两种情况下，`self.main_order dictionary`对象将`instrument`和`order`实例作为键值对保存。这将在后面有用(在*EMA-常规订单策略-编码策略 _ 退出 _ 头寸方法*配方中)，用于退出该方法创建的头寸。

在运行时，AlgoBulls 核心引擎会用适当的代理实例替换`self.broker`属性。因此，相同的代码可以在 AlgoBulls 平台支持的所有代理上运行。

# EMA-常规订单策略–编码策略 _ 选择 _ 工具 _ 退出方法

在这个菜谱中，您将继续编写`StrategyEMARegularOrder`类的代码。在这里，您编写了`strategy_select_instruments_for_exit()`方法，这是一个由`StrategyBase`基类强制执行的强制方法。AlgoBulls 核心引擎为每个新蜡烛线调用此方法，用于回溯测试、纸面交易和真实交易服务(如果有任何未结头寸)。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_select_instruments_for_exit()`方法。

## 做好准备

在开始制作这个食谱之前，确保你已经按照前面的食谱做了。

## 怎么做…

继续编写`StrategyEMARegularOrder`类的代码。我们需要定义一种新的方法，用于根据交叉值的计算从`instruments_bucket`中选择仪器，以退出现有位置:

```
class StrategyEMARegularOrder(StrategyBase):
    # Previous methods not shown
    def strategy_select_instruments_for_exit(self, candle, 
                                             instruments_bucket):
        selected_instruments_bucket = []
        sideband_info_bucket = []
        for instrument in instruments_bucket:
            if self.main_order.get(instrument) is not None:
                crossover_value = self.get_crossover_value(instrument)
                if crossover_value in [1, -1]:
                    selected_instruments_bucket.append(instrument)
                    sideband_info_bucket.append({'action': 'EXIT'})
        return selected_instruments_bucket, sideband_info_bucket
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyEMARegularOrder`类。我们为这个类定义了一个新方法`strategy_select_instruments_for_exit()`，描述如下:

*   这个方法有两个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instruments_bucket`:一个`SetInstruments`类型的对象。该对象持有通过`strategy_enter_position()`方法提前进入头寸的金融工具。
*   您创建了两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。
*   你在`instruments_bucket`上运行一个`for`循环。对于每个仪器，使用`'if self.main_order.get(instrument) is not None:'`线检查是否有给定仪器输入的位置。只有在职位已经存在的情况下，您才能继续。
*   您调用`self.get_crossover_value()`并将它的值保存到一个新属性`crossover_value`。基于`crossover_value`的值，你做一个决定，如下:
*   如果`crossover_value`不是`1`就是`-1`，就说明发生了交叉。您需要执行以下操作:
*   将`instrument`属性附加到`selected_instruments_bucket`上。
*   向`sideband_info_bucket`属性追加一个`{'action': 'EXIT'}`字典。

*   如果`crossover_value`既不是`1`也不是`-1`，这意味着该策略没有给出任何信号。你在这里什么都不做。
*   最后，您返回两个属性:`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已经被填充，或者可能仍然是空列表。

回想一下，对每个蜡烛调用了`strategy_select_instruments_for_exit()`方法，所以对每个新的蜡烛重复前面的步骤。在适当的蜡烛里，如果有一个位置，你可能会得到一个`EXIT`信号，而在其他位置，你不会得到任何信号。根据这个信号，你可以通过下一个适当的订单来平仓，这将在下一个食谱中讨论。

# EMA-常规订单策略–编码策略 _ 退出 _ 头寸方法

在这个菜谱中，您将继续编写`StrategyEMARegularOrder`类的代码。在这里，您将编写`strategy_exit_position()`方法，这是由`StrategyBase`基类执行的最后一个强制方法。每次`strategy_select_instruments_for_exit`方法返回非空数据时，AlgoBulls 核心引擎都会调用该方法。到这个菜谱结束时，你将已经完成了对`StrategyEMARegularOrder`类的编码。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_select_instruments_for_exit()`方法。

## 做好准备

在开始制作这个食谱之前，请确保你已经按照前面的食谱做了。

## 怎么做…

继续编写`StrategyEMARegularOrder`类的代码。根据`sideband_info`为给定仪器定义退出位置的方法:

```
class StrategyEMARegularOrder(StrategyBase):
    # Previous methods not shown
    def strategy_exit_position(self, candle, instrument, sideband_info):
        if sideband_info['action'] == 'EXIT':
            self.main_order[instrument].exit_position()
            self.main_order[instrument] = None
            return True
        return False

```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyEMARegularOrder`类。我们为这个类定义了一个新方法`strategy_exit_position()`，描述如下:

*   这个方法有三个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instrument`:表示金融工具的`Instrument`类型的对象。
*   `sideband_info`:dictionary 对象，保存关于为`instrument`属性放置的交易的信息。这个物体看起来像`{'action': 'EXIT'}`。
*   如果`sideband_info`是`{'action': 'EXIT'}`，执行以下操作:
*   您使用`self.main_order[instrument]`获取订单(回想一下，`self.main_order`是一个字典，它将工具和相应的订单实例保存为键值对。)
*   您可以通过调用其`exit_position()`方法来退出该订单的头寸。
*   你将`self.main_order`中`instrument`键对应的值重置为`None`。这表明不再有对应于`instrument`的位置空缺。
*   您返回`True`，向 AlgoBulls 核心引擎发出信号，表明在本次调用中已经为`instrument`退出了一个仓位。

*   如果`sideband_info`不为`{'action': 'EXIT'}`，则返回`False`，向 AlgoBulls 核心引擎发出信号，表明在此调用中没有为`instrument`退出任何位置。

在运行时，AlgoBulls 核心引擎会用适当的代理实例替换`self.broker`属性。因此，相同的代码可以在 AlgoBulls 平台支持的所有代理上运行。

现在您已经完成了对`StrategyEMARegularOrder`类的编码。

# EMA-常规订单策略-将策略上传到 AlgoBulls 交易平台

在本菜谱中，您将在 AlgoBulls 交易平台上上传您在前面的菜谱中创建的策略类`StrategyEMARegularOrder`。一旦它被上传，你就可以在相同的代码基础上进行回溯测试、纸上交易和真实交易。

## 做好准备

确保您已经在 AlgoBulls 平台([https://algobulls.com](https://algobulls.com))上设置了您的帐户，以获取您的 API 令牌。设立账户是免费的。根据您的使用情况，使用其服务可能会产生费用。你可以从网站上的免费包开始。详见*附录二*。

## 怎么做…

我们为此配方执行以下步骤:

1.  导入必要的模块:

```
>>> import inspect
>>> from pyalgotrading.algobulls import AlgoBullsConnection
>>> from pyalgostrategypool.strategy_ema_regular_order import StrategyEMARegularOrder
```

2.  创建新的 AlgoBulls 连接对象:

```
>>> algobulls_connection = AlgoBullsConnection()
```

3.  获取授权 URL:

```
>>> algobulls_connection.get_authorization_url()
```

我们得到以下输出:

```
Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login
'https://app.algobulls.com/user/login'
```

4.  使用您的 AlgoBulls 凭证登录到前面的链接，获取您的令牌，并在此处进行设置(更多详细信息，请参见*附录 II* ):

```
>>> algobulls_connection.set_access_token('80b7a69b168c5b3f15d56688841a8f2da5e2ab2c')
```

5.  在上传策略之前，您可以检查您的策略代码，以确保您上传的是正确的策略:

```
>>> print(inspect.getsource(StrategyEMARegularOrder))
```

我们得到以下输出:

```
class StrategyEMARegularOrder(StrategyBase):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.timeperiod1 = self.strategy_parameters['timeperiod1']
        self.timeperiod2 = self.strategy_parameters['timeperiod2']

        self.main_order = None

    def initialize(self):
        self.main_order = {}

    @staticmethod
    def name():
        return 'EMA Regular Order Strategy'
    ...
    def strategy_exit_position(self, candle, instrument, 
                               sideband_info):
        if sideband_info['action'] == 'EXIT':
            self.main_order[instrument].exit_position()
            self.main_order[instrument] = None
            return True
        return False
```

这里没有显示完整的输出。请访问以下链接阅读完整输出:

[https://github . com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy _ EMA _ regular _ order . py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_ema_regular_order.py)。

6.  将`StrategyEMARegularOrder`上传到 AlgoBulls 平台。这为您的 AlgoBulls 客户创造了一个新策略:

```
>>> algobulls_connection.create_strategy(StrategyEMARegularOrder)
```

我们得到以下输出(您的输出可能不同):

```
Validating Strategy...
{'details': `'strategy_code': '49287246f9704bbcbad76ade9e2091d9'}
```

## 它是如何工作的…

我们在*步骤 1* 中导入必要的模块。在*步骤 2* 中，创建了一个`AlgoBullsConnection`类的实例，命名为`algobulls_connection`。在*步骤 3* 中，您使用`algobulls_connection`对象的`get_authorization_url()`方法获得授权 URL。您应通过网络浏览器访问此 URL，登录 AlgoBulls 平台并获取您的开发者访问令牌。(您可以在*附录二*的截图中找到更多关于从 AlgoBulls 平台获取开发者访问令牌的详细信息。)您复制访问令牌，并使用`algobulls_connection`的`set_access_token()`方法在*步骤 4* 中设置它。如果令牌被接受，则与 AlgoBulls 平台成功建立连接。

我们在*步骤 1* 到 *5* 中编码的`StrategyEMARegularOrder`策略类在`pyalgostrategypool`包中也有。我们在*步骤 1* 中导入这个类。或者，您也可以将策略类保存在单独的 Python 模块中，并在*步骤 1* 中导入，而不是从`pyalgostrategypool`导入。

您使用`algobulls_connection`的`upload_strategy()`方法上传`StrategyEMARegularOrder`策略类，将它作为参数传递。如果上传成功，你会得到一个带有`strategy_code`的成功消息，这是一个唯一的字符串。`strategy_code`可以在以后用来做一切与策略相关的事情——比如，编辑策略，进行回溯测试([第九章](09.html)，*算法交易——回溯测试*)，进行纸上交易([第十章](10.html)，*算法交易——**纸上交易*，进行真实交易([第十一章](11.html)，*算法交易——**真实交易*)。

## 还有更多…

如果上传后对策略进行了更改，您可以使用`algobulls_connection`的`upload_strategy()`方法，以更新后的类和`overwrite=True`作为参数，在 AlgoBulls 平台上更新策略。如果更改上传成功，您将收到一条成功消息。

修改已经上传的策略:

```
>>> algobulls_connection.create_strategy(StrategyEMARegularOrder, 
                                         overwrite=True)
```

我们得到以下输出:

```
Validating Strategy…
{'details': 'success'}
```

AlgoBulls 平台不允许使用多个同名策略(由`name()`方法返回)。`overwrite=True`参数更新同名的现有策略(如果存在的话)。如果没有将`overwrite=True`传递给`create_strategy()`方法，则默认值为`False`，这意味着它试图在 AlgoBulls 平台上创建一个新策略。

# MACD-括号-顺序策略–编码 __init__、initialize、name 和 versions_supported 方法

这个菜谱演示了`StrategyMACDBracketOrder`类的初始编码。完整的类将在本章第 11 个配方结束时编码。在本食谱中，您将编写以下方法:

*   `__init__()`
*   `initialize()`
*   `name()`
*   `versions_supported()`

详细了解 MACD 技术指标，请参考[第五章](05.html)、*计算并绘制技术指标*的*趋势指标-移动平均线收敛发散*配方。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`__init__()`和`initialize()`方法。

## 做好准备

确保 Python 名称空间中有`StrategyBase`和`pyalgotrading`常量。参见本章的*技术要求*部分进行设置。

## 怎么做…

创建一个名为`StrategyMACDBracketOrder`的新类。从`StrategyBase`子类化它。定义所需的四种方法:

```
class StrategyMACDBracketOrder(StrategyBase):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.fastMA_period = self.strategy_parameters['fastma_period']
        self.slowMA_period = self.strategy_parameters['slowma_period']
        self.signal_period = self.strategy_parameters['signal_period']
        self.stoploss = self.strategy_parameters['stoploss_trigger']
        self.target = self.strategy_parameters['target_trigger']
        self.trailing_stoploss = \
                      self.strategy_parameters['trailing_stoploss_trigger']

        self.main_order = None

    def initialize(self):
        self.main_order = {}

    @staticmethod
    def name():
        return 'MACD Bracket Order Strategy'
    @staticmethod
    def versions_supported():
        return VERSION_3_2_0
```

## 它是如何工作的…

在这个菜谱中，我们将创建从`StrategyBase`继承而来的`StrategyEMARegularOrder`类。我们将为这个类定义四个方法，描述如下:

*   `__init__()`方法:这是你制定新战略时要做的第一件事。首先，创建这个方法，并使用`super()`调用父类`__init__()`方法。这有助于 AlgoBulls 核心引擎创建进一步发展战略所需的必要数据结构。接下来，您从`self.strategy_parameters`创建六个属性:
*   `self.fastMA_period`
*   `self.slowMA_period`

*   `self.signal_period`
*   `self.stoploss`
*   `self.target`
*   `self.trailing_stoploss`

`self.strategy_parameters`是一个字典对象，可用于从`StrategyBase`子类化的每个策略。([第七招第九章](09.html)、*算法交易——**回溯测试*，讨论这些值在运行时如何传递给`self.strategy_parameters`。)这些参数将在本章的下一个配方中用作 MACD 技术指标的参数。最后，创建一个新属性`self.main_order`，一个空字典。我们将使用它来保存在执行该策略期间下的所有未结订单的句柄。

*   `initialize()`方法:该方法在每个交易日开始时被调用，以将任何内部变量初始化为它们的默认状态。对于实盘交易和纸面交易，这个方法调用一次。对于多日回溯测试，这个方法被多次调用，在每个新的交易日开始时调用一次。在这个方法中，您将`self.main_order`初始化为一个空字典。
*   `name()`方法:这是一个静态方法，返回这个策略的名称。这是在利用回溯测试、纸上交易和真实交易服务时使用的策略。在这个方法中，您只需返回一个字符串`MACD Bracket Order`。在这个方法中，您可以返回您选择的任何字符串。

*   `versions_supported()`方法:这个静态方法用于返回 AlgoBulls 核心引擎版本，该策略是为该版本创建的。通常，随着 AlgoBulls 核心引擎的新升级，可能会引入一些向后不兼容的更改。这种方法有助于确保该策略始终在 AlgoBulls 核心引擎的正确版本上运行。在这个方法中，您从 constants 模块返回最高可用版本，在编写本章时是 VERSION_3_2_0。

这四种方法是强制性的；它们由`StrategyBase`基类强制执行，不能被跳过。

# MACD 括号订单策略–编码策略 _ 选择 _ 工具 _ 输入方法

在这个菜谱中，您将继续编写`StrategyMACDBracketOrder`类。在这里，您将编写`strategy_select_instruments_for_entry()`方法，这是一个由`StrategyBase`基类强制执行的强制方法。AlgoBulls 核心引擎在每个新蜡烛上调用这个方法，用于回溯测试、纸面交易和实际交易服务。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_select_instruments_for_entry()`方法。

## 做好准备

在开始这个配方之前，确保你已经按照前面的配方创建了`StrategyMACDBracketOrder`类。

## 怎么做…

继续编写`StrategyMACDBracketOrder`类的代码。定义两种新方法——一种方法用于获取 MACD 线和 MACD 历史信号之间的交叉值，另一种方法用于根据计算的交叉值从`instruments_bucket`选择输入新位置的工具:

```
class StrategyMACDBracketOrder(StrategyBase):
    # Note: Some methods are not shown here    
    def get_crossover_value(self, instrument):
        hist_data = self.get_historical_data(instrument)
        macdline, macdsignal, _ = talib.MACD(hist_data['close'], 
                                           fastperiod=self.fastMA_period, 
                                           slowperiod=self.slowMA_period, 
                                           signalperiod=self.signal_period)
        crossover_value = self.utils.crossover(macdline, macdsignal)
        return crossover_value
    def strategy_select_instruments_for_entry(self, candle, 
                                              instruments_bucket):
        selected_instruments_bucket = []
        sideband_info_bucket = []
        for instrument in instruments_bucket:
            crossover_value = self.get_crossover_value(instrument)
            if crossover_value == 1:
                selected_instruments_bucket.append(instrument)
                sideband_info_bucket.append({'action': 'BUY'})
            elif crossover_value == -1:
                if self.strategy_mode is StrategyMode.INTRADAY:
                    selected_instruments_bucket.append(instrument)
                    sideband_info_bucket.append({'action': 'SELL'})
        return selected_instruments_bucket, sideband_info_bucket   
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyMACDBracketOrder`类。我们为此类定义了两个新方法，描述如下:

*   `get_crossover_value()`方法:这是一个助手方法。它将`instrument`作为参数(连同`self`)。这是必须计算交叉价值的金融工具。您使用`self.get_historical_data()`方法获取最新的历史数据，并将其分配给一个新属性`hist_data`。我们将`instrument`作为参数传递给这个方法。`hist_data`属性是一个具有`timestamp`、`open`、`high`、`low`、`close`和`volume`列的`pandas.DataFrame`对象。

提取的历史数据的默认持续时间是过去 15 天。使用`talib.MACD`函数计算`hist_data`收盘时的 MACD。它采用以下附加参数:

*   `fastperiod`:我们在这里经过`self.fastMA_period`。
*   `slowperiod`:我们在这里经过`self.slowMA_period`。
*   `signalperiod:`我们在这里经过`self.signal_period`。

这个计算出的 MACD 数据是一个`pandas.Series`对象的元组，您将其分配给`macdline`、`macdsignal`和`_`(元组中的最后一个对象被分配给`_`，因为它不是必需的)。(关于 MACD 的计算，详见第五章、*计算并绘制技术指标*中[的第三个配方。)使用`self.utils.crossover(macdline, macdsignal)`计算`macdline`和`macdsignal`之间的交叉值，并将其分配给新属性`crossover_value`。`crossover()`函数调用的工作方式如下:](05.html)

*   它接受两个可重复项作为输入。我们在这里通过`macdline`和`macdsignal`。
*   如果`macdline`向上穿越`macdsignal`，穿越函数返回`1`。

*   如果`macdline`向下穿过`macdsignal`，交叉函数返回`-1`。
*   如果`macdline`和`macdsignal`之间没有交叉，那么交叉函数返回`0`。

最后，你返回`crossover_value`。

*   `strategy_select_instruments_for_entry()`方法:这个方法有两个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instruments_bucket`:`SetInstruments`类型的对象，包含可用于创建新头寸的所有金融工具。我们在策略执行的时候传递这些数据([第八章](09.html)、*回测策略*的第二招)。

您创建了两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。你在`instruments_bucket`上运行一个`for`循环。对于每个乐器，您调用`self.get_crossover_value()`，并将其值保存到一个新的属性`crossover_value`。基于`crossover_value`的值，您做出如下决定:

*   如果`crossover_value`为`1`，则表示该策略正在给出一个`BUY`信号。您需要执行以下操作:
*   将`instrument`追加到`selected_instruments_bucket`上。
*   向`sideband_info_bucket`属性追加一个`{'action': 'BUY'}`字典。
*   如果`crossover_value`为`-1`，则表示该策略正在给出一个`SELL`信号。您需要执行以下操作:
*   将`instrument`追加到`selected_instruments_bucket`上。
*   向`sideband_info_bucket`属性追加一个`{'action': 'SELL'}`字典。
*   如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有给出信号。你在这里什么都不做。
*   最后，您返回两个属性:`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已被填充，或者可能仍为空列表。

回想一下，对每个蜡烛调用了`strategy_select_instruments_for_entry()`方法，所以对每个新的蜡烛重复前面的步骤。在合适的烛光下，你会得到一个`BUY`或`SELL`信号，而在其他的烛光下，你将得不到任何信号。根据这个信号，你可以下适当的订单，这将在下一个食谱中讨论。

`strategy_select_instruments_for_entry()`方法由`StrategyBase`基类执行，必须为每个策略定义。`get_crossover_value()`方法是一个助手方法，这意味着它不是由`StrategyBase`基类强制执行的。您可以选择不定义这个函数，或者定义多个这样的帮助函数。

# MACD-括号-顺序策略-编码策略 _ 输入 _ 位置方法

在这个菜谱中，您将继续编写`StrategyMACDBracketOrder`类的代码。在这里，您将编写`strategy_enter_position()`方法，这是一个由`StrategyBase`基类强制执行的强制方法。每次`strategy_select_instruments_for_entry()`方法返回非空数据时，AlgoBulls 核心引擎都会调用该方法。对于回溯测试、纸面交易和真实交易服务，可能不会对每个新蜡烛线都调用这个方法。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_enter_position()`方法。

## 做好准备

在开始制作这个食谱之前，请确保你已经按照前面的食谱做了。

## 怎么做…

继续编写`StrategyMACDBracketOrder`类的代码。定义一种方法，为给定的仪器打孔新订单并输入新位置:

```
class StrategyMACDBracketOrder(StrategyBase):
    # Note: Some methods are not shown here 
    def strategy_enter_position(self, candle, instrument, sideband_info):
        if sideband_info['action'] == 'BUY':
            qty = self.number_of_lots * instrument.lot_size
            ltp = self.broker.get_ltp(instrument)
            self.main_order[instrument] = \
                self.broker.BuyOrderBracket(
                    instrument=instrument,
                    order_code= BrokerOrderCodeConstants.INTRADAY,
                    order_variety= BrokerOrderVarietyConstants.LIMIT,
                    quantity=qty,
                    price=ltp,
                    stoploss_trigger=ltp - (ltp * self.stoploss),
                    target_trigger=ltp + (ltp * self.target),
                    trailing_stoploss_trigger=ltp * self.trailing_stoploss)
        elif sideband_info['action'] == 'SELL':
            qty = self.number_of_lots * instrument.lot_size
            ltp = self.broker.get_ltp(instrument)
            self.main_order[instrument] = \
                self.broker.SellOrderBracket(
                    instrument=instrument,
                    order_code=BrokerOrderCodeConstants.INTRADAY,
                    order_variety=BrokerOrderVarietyConstants.LIMIT,
                    quantity=qty,
                    price=ltp,
                    stoploss_trigger=ltp + (ltp * self.stoploss),
                    target_trigger=ltp - (ltp * self.target),
                    trailing_stoploss_trigger=ltp * self.trailing_stoploss)
        else:
            raise SystemExit(f'Got invalid sideband_info value: 
                             {sideband_info}')
        return self.main_order[instrument]
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了一个新方法`strategy_enter_position()`，描述如下:

*   这个方法有三个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instrument`:表示金融工具的`Instrument`类型的对象。

*   `sideband_info`:dictionary 对象，保存关于为`instrument`属性放置的交易的信息。这个物体看起来像`{'action': [action_value]}`，这里的`[action_value]`可以是`'BUY'`也可以是`'SELL'`。
*   通过将`self.number_of_lots`乘以`instrument.lot_size`来计算订单的数量，并将其分配给一个新的属性 qty。`self.number_of_lots`属性保存了关于交易手数的信息，在执行这个策略时可以传递这些信息。`instrument.lot_size`属性为`instrument`保存`lot_size`，T5 是一个正整数。例如，如果传递的批次数量为 2，且器械的批量大小为 10，则订单的数量为 2 * 10 = 20。

*   如果`sideband_info`是`{'action': 'BUY'}`，您通过创建`self.broker.BuyOrderBracket`类的实例(参考[第 7 章](07.html)、*在交易所*上下单并覆盖订单的第一个配方)并将其值赋给`self.main_order[instrument]`来下单`BUY`交易类型的`Bracket`。
*   类似地，如果`sideband_info`是`{'action': 'SELL'}`，通过创建一个`self.broker.SellOrderBracket`类的实例(参考[第 7 章](07.html)、*在交易所*上放置支架和封面订单的第一个方法)并将其值赋给`self.main_order[instrument]`，您可以下一个`BUY`交易类型的`Bracket`订单。

在这两种情况下，`self.main_order`字典对象将`instrument`和`order`实例作为一个键值对保存。这将在后面有用(在*MACD-套期保值-订单策略-编码策略 _ 退出 _ 头寸方法*配方中)，用于退出该方法创建的头寸。

在运行时，AlgoBulls 核心引擎会用适当的代理实例替换`self.broker`属性。因此，相同的代码可以在 AlgoBulls 平台支持的所有代理上运行。

# MACD 括号顺序策略–编码策略 _ 选择 _ 工具 _ 退出方法

在这个菜谱中，您将继续编写`StrategyMACDBracketOrder`类的代码。在这里，您将编写`strategy_select_instruments_for_exit()`方法，这是一个由`StrategyBase`基类强制执行的强制方法。AlgoBulls 核心引擎为每个新蜡烛线调用该方法，用于回溯测试、纸面交易和实际交易服务。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_select_instruments_for_exit()`方法。

## 做好准备

在开始制作这个食谱之前，请确保你已经按照前面的食谱做了。

## 怎么做…

继续编写`StrategyMACDBracketOrder`类的代码。根据交叉值的计算，定义一种从`instruments_bucket`中选择器械退出现有位置的新方法:

```
class StrategyMACDBracketOrder(StrategyBase):
    # Note: Some methods are not shown here   
    def strategy_select_instruments_for_exit(self, candle, 
                                             instruments_bucket):
        selected_instruments_bucket = []
        sideband_info_bucket = []
        for instrument in instruments_bucket:
            if self.main_order.get(instrument) is not None:
                crossover_value = self.get_crossover_value(instrument)
                if crossover_value in [1, -1]:
                    selected_instruments_bucket.append(instrument)
                    sideband_info_bucket.append({'action': 'EXIT'})
        return selected_instruments_bucket, sideband_info_bucket    
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了一个新方法`strategy_select_instruments_for_exit()`，描述如下:

*   这个方法有两个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instruments_bucket`:一个`SetInstruments`类型的对象。该对象持有通过`strategy_enter_position()`方法提前进入头寸的金融工具。
*   您创建了两个空列表，`selected_instruments_bucket`和`sideband_info_bucket`。

*   你在`instruments_bucket`上运行一个`for`循环。对于每个仪器，使用`'if self.main_order.get(instrument) is not None:'`线检查是否有给定仪器输入的位置。只有在职位已经存在的情况下，您才能继续。
*   您调用`self.get_crossover_value()`并将它的值保存到一个新属性`crossover_value`。基于`crossover_value`的值，你做一个决定，如下:
*   如果`crossover_value`不是`1`就是`-1`，就说明发生了交叉。您需要执行以下操作:
*   将`instrument`属性附加到`selected_instruments_bucket`上。
*   向`sideband_info_bucket`属性追加一个`{'action': 'EXIT'}`字典。
*   如果`crossover_value`既不是`1`也不是`-1`，这意味着策略没有给出信号。你在这里什么都不做。
*   最后，您返回两个属性，`selected_instruments_bucket`和`sideband_info_bucket`。这些属性可能已被填充，或者可能仍为空列表。

回想一下，对每个蜡烛调用了`strategy_select_instruments_for_exit()`方法，所以对每个新的蜡烛重复前面的步骤。在适当的蜡烛里，如果有一个位置，你可能会得到一个`EXIT`信号，而在其他位置，你不会得到任何信号。根据这个信号，你可以通过下一个适当的订单来平仓，这将在下一个食谱中讨论。

# MACD-括号-顺序策略-编码策略 _ 退出 _ 位置方法

在这个菜谱中，您将继续编写`StrategyMACDBracketOrder`类的代码。在这里，您将编写`strategy_exit_position()`方法，这是由`StrategyBase`基类执行的最后一个强制方法。每次`strategy_select_instruments_for_exit`方法返回非空数据时，AlgoBulls 核心引擎都会调用该方法。到这个菜谱结束时，你将已经完成了对`StrategyMACDBracketOrder`类的编码。

请参考本章介绍中的流程图，了解 AlgoBulls 核心引擎在策略执行过程中如何调用`strategy_select_instruments_for_exit()`方法。

## 做好准备

在开始制作这个食谱之前，请确保你已经按照前面的食谱做了。

## 怎么做…

继续编写`StrategyMACDBracketOrder`类的代码。根据`sideband_info`为给定仪器定义退出位置的方法:

```
class StrategyMACDBracketOrder(StrategyBase):
    # Note: Some methods are not shown here   
    def strategy_exit_position(self, candle, instrument, 
                               sideband_info):
        if sideband_info['action'] == 'EXIT':
            self.main_order[instrument].exit_position()
            self.main_order[instrument] = None
            return True
        return False
```

## 它是如何工作的…

在这个菜谱中，我们继续编写`StrategyMACDBracketOrder`类。我们为这个类定义了一个新方法`strategy_exit_position()`，描述如下:

*   这个方法有三个参数，除了`self`:
*   `candle`:一个`CandleTime`类型的对象，包含当前蜡烛的时间戳。
*   `instrument`:表示金融工具的`Instrument`类型的对象。

*   `sideband_info`:dictionary 对象，保存关于为`instrument`属性放置的交易的信息。这个物体看起来像`{'action': `EXIT`}`。

*   如果`sideband_info`是`{'action': 'EXIT'}`，执行以下操作:
*   您使用`self.main_order[instrument]`获取订单。(回想一下，`self.main_order`是一个字典，它将工具和相应的订单实例保存为键值对。)
*   您可以通过调用其`exit_position()`方法来退出该订单的头寸。

因为这是一个`Bracket`订单策略，所以`target`或`stoploss`订单有可能在我们的策略不知情的情况下成交，仓位也有可能退出。您仍然可以使用`exit_position()`方法来处理这些场景。`exit_position()`方法适用于以下两种退出场景:

*   职位空缺，您想自己退出。
*   由于完成了`stoploss`订单或`target`订单，经纪人已经退出了该头寸，并且没有采取任何措施。
*   你将`self.main_order`中`instrument`键对应的值重置为`None`。这表明不再有对应于`instrument`的位置空缺。
*   您返回`True`，向 AlgoBulls 核心引擎发出信号，表明在本次调用中已经为`instrument`退出了一个仓位。
*   如果`sideband_info`不是`{'action': 'EXIT'}`，则返回`False`，向 AlgoBulls 核心引擎发出信号，表明在此调用中没有为`instrument`退出任何位置。

在运行时，AlgoBulls 核心引擎会用适当的代理实例替换`self.broker`属性。因此，相同的代码可以在 AlgoBulls 平台支持的所有代理上运行。

现在您已经完成了对`StrategyMACDBracketOrder`类的编码。

# MACD-括弧-订单策略-在 AlgoBulls 交易平台上传策略

在本菜谱中，您将在 AlgoBulls 交易平台上上传您在前面五个菜谱中创建的策略类`StrategyMACDBracketOrder`。一旦它被上传，你就可以在相同的代码基础上进行回溯测试、纸上交易和真实交易。

## 做好准备

确保您已经在 AlgoBulls 平台([https://algobulls.com](https://algobulls.com))上设置了您的帐户，以获取您的 API 令牌。设立账户是免费的。根据您的使用情况，使用其服务可能会产生费用。你可以从网站上的免费包开始。详见*附录二*。

## 怎么做…

我们为此配方执行以下步骤:

1.  导入必要的模块:

```
>>> import inspect
>>> from pyalgostrategypool.strategy_macd_bracket_order import StrategyMACDBracketOrder
>>> from pyalgotrading.algobulls import AlgoBullsConnection
```

2.  创建新的 AlgoBulls 连接对象:

```
>>> algobulls_connection = AlgoBullsConnection()
```

3.  获取授权 URL:

```
>>> algobulls_connection.get_authorization_url()
```

我们得到以下输出:

```
Please login to this URL with your AlgoBulls credentials and get your developer access token: https://app.algobulls.com/user/login
'https://app.algobulls.com/user/login'
```

4.  使用您的 AlgoBulls 凭证登录到前面的链接，获取您的令牌，并在此处进行设置(更多详细信息，请参见*附录 II* ):

```
>>> algobulls_connection.set_access_token('80b7a69b168c5b3f15d56688841a8f2da5e2ab2c')
```

5.  在上传策略之前，您可以检查您的策略代码，以确保您上传的是正确的策略:

```
>>> print(inspect.getsource(StrategyMACDBracketOrder))
```

我们得到以下输出:

```
class StrategyMACDBracketOrder(StrategyBase):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.fastMA_period = \
            self.strategy_parameters['fastma_period']
        self.slowMA_period = \
            self.strategy_parameters['slowma_period']
        self.signal_period = \
            self.strategy_parameters['signal_period']
        self.stoploss = 
            self.strategy_parameters['stoploss_trigger']
        self.target = 
            self.strategy_parameters['target_trigger']
        self.trailing_stoploss = 
            self.strategy_parameters['trailing_stoploss_trigger']

        self.main_order = None

    def initialize(self):
        self.main_order = {}

    @staticmethod
    def name():
        return 'MACD Bracket Order Strategy'
    ...
    def strategy_exit_position(self, candle, instrument, 
                               sideband_info):
        if sideband_info['action'] == 'EXIT':
            self.main_order[instrument].exit_position()
            self.main_order[instrument] = None
            return True
        return False
```

这里没有显示完整的输出。请访问以下链接阅读完整输出:

[https://github . com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy _ MACD _ bracket _ order . py](https://github.com/algobulls/pyalgostrategypool/blob/master/pyalgostrategypool/strategy_macd_bracket_order.py)。

6.  将`StrategyMACDBracketOrder`上传到 AlgoBulls 平台。这为您的 AlgoBulls 客户创造了一个新策略:

```
>>> algobulls_connection.create_strategy(StrategyMACDBracketOrder)
```

我们得到以下输出(您的输出可能不同):

```
Validating Strategy...
{'details': 'success', 'strategy_code': '4faf514fe096432b8e9f80f5951bd2ea'}
```

## 它是如何工作的…

我们在*步骤 1* 中导入必要的模块。在*步骤 2* 中，创建了一个`AlgoBullsConnection`类的实例，命名为`algobulls_connection`。在*步骤 3* 中，您使用`algobulls_connection`对象的`get_authorization_url()`方法获得授权 URL。您应通过网络浏览器访问此 URL，登录 AlgoBulls 平台并获取您的开发者访问令牌。(您可以在*附录二*的截图中找到更多关于从 AlgoBulls 平台获取开发者访问令牌的详细信息。)您复制访问令牌，并使用`algobulls_connection`的`set_access_token()`方法在*步骤 4* 中设置它。如果令牌被接受，则与 AlgoBulls 平台成功建立连接。
我们在*步骤 5* 中编码的`StrategyMACDBracketOrder`策略类也可以在`pyalgostrategypool`包中获得。我们在*步骤 1* 中导入这个类。或者，您也可以将策略类保存在单独的 Python 模块中，并在*步骤 1* 中导入，而不是从`pyalgostrategypool`导入。

您使用`algobulls_connection`的`upload_strategy()`方法上传`StrategyMACDBracketOrder`策略类，将它作为参数传递。如果上传成功，你会得到一个带有`strategy_code`的成功消息，这是一个唯一的字符串。`strategy_code`可以在后面的章节中用来做一切与策略相关的事情——例如，编辑策略、执行回溯测试、执行纸上交易和执行真实交易。

## 还有更多…

如果上传后对策略进行了更改，您可以使用`algobulls_connection`的`upload_strategy()`方法，以更新后的类和`overwrite=True`作为参数，在 AlgoBulls 平台上更新策略。如果更改上传成功，您将收到一条成功消息。

您可以修改已上传的策略，如下所示:

```
>>> algobulls_connection.create_strategy(StrategyMACDBracketOrder, 
                                         overwrite=True)
```

我们得到以下输出:

```
Validating Strategy…
{'details': 'success'}
```

AlgoBulls 平台不允许使用多个同名策略(由`name()`方法返回)。`overwrite=True`参数更新同名的现有策略(如果存在的话)。如果没有将`overwrite=True`传递给`create_strategy()`方法，则默认值为`False`，这意味着它试图在 AlgoBulls 平台上创建一个新策略。