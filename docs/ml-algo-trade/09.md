# 九、波动率预测和统计套利的时间序列模型

在*第 7 章**线性模型——从风险因子到资产回报预测*中，我们引入了用于推断和预测的线性模型，从静态模型开始，用于与对产出有直接影响的横截面输入的同期关系。我们提出了**普通最小二乘**（**OLS**）学习算法，并发现它为正确指定的模型生成无偏系数，残差与输入变量不相关。加上残差具有恒定方差的假设，保证 OLS 在无偏估计量中产生最小的均方预测误差。

当我们了解 Fama-Macbeth 回归如何估计风险因子随时间和资产的价值时，我们还遇到了具有横截面和时间序列维度的面板数据。然而，不同时间的回报之间的关系通常相当低，因此此过程在很大程度上可以忽略时间维度。

此外，我们还讨论了正则化岭回归和套索回归模型，它们产生有偏的系数估计，但可以减少均方预测误差。这些预测模型从更动态的角度出发，将历史收益与其他输入相结合，预测远期收益。

在本章中，我们将建立动态线性模型，以明确表示时间，并包括在特定间隔或滞后观察到的变量。时间序列数据的一个关键特征是它们的顺序：与横截面数据一样，我们的数据不是单个观测值的随机样本，而是我们无法重复的随机过程的单一实现。

我们的目标是确定时间序列中的系统模式，帮助我们预测时间序列在未来的行为。更具体地说，我们将关注从输出的历史序列中提取信号的模型，以及（可选）其他同期或滞后输入变量，以预测输出的未来值。例如，我们可以尝试使用过去的回报率，结合基准或宏观经济变量的历史回报率来预测股票的未来回报率。在第 4 部分中，我们将重点讨论线性时间序列模型，然后转向非线性模型，如递归或卷积神经网络。

鉴于交易固有的时间维度，时间序列模型非常流行。主要应用包括预测资产收益率和波动率，以及识别资产价格序列的共同变动。随着越来越多的连接设备收集具有潜在信号内容的定期测量数据，时间序列数据可能变得更加普遍。

我们将首先介绍可用于诊断时间序列特征和提取捕获潜在模式的特征的工具。然后，我们将介绍如何诊断和实现时间序列平稳性。接下来，我们将介绍单变量和多变量时间序列模型，并应用它们来预测宏观数据和波动模式。最后，我们将介绍协整的概念以及如何应用协整来制定配对交易策略。

我们将特别介绍以下主题：

*   如何使用时间序列分析来准备和通知建模过程
*   单变量自回归和移动平均模型的估计和诊断
*   建立**自回归条件异方差**（**ARCH**模型预测波动性
*   如何建立多元向量自回归模型
*   利用协整制定成对交易策略

您可以在 GitHub 存储库的相应目录中找到本章的代码示例以及指向其他资源的链接。笔记本电脑包括图像的彩色版本。关于从投资角度对本章主题的全面介绍，请参见 Tsay（2005）和 Fabozzi、Focardi 和 Kolm（2010）。

# 诊断和特征提取工具

时间序列是由离散间隔分隔的值序列，这些离散间隔通常为偶数间隔（缺失值除外）。时间序列通常被建模为一个随机过程，由一组随机变量组成![](img/B15439_09_001.png)，每个时间点对应一个变量![](img/B15439_09_002.png)。单变量时间序列由每个时间点的单个值*y*组成，而多变量时间序列由多个可由向量表示的观测值组成。

不同时间点之间的周期数![](img/B15439_09_003.png)*t*<sub style="font-style: italic;">i</sub>*t*<sub style="font-style: italic;">j</sub>称为**滞后**，每个时间序列的*t*-1 个明显滞后。正如给定时间点上不同变量之间的关系是横截面模型的关键，由给定滞后分离的数据点之间的关系是分析和利用时间序列模式的基础。

对于横截面模型，我们分别用标签*y*和*x*区分输入变量和输出变量，或目标变量和预测变量。在时间序列上下文中，结果*y*的部分或全部滞后值![](img/B15439_09_004.png)在横截面上下文中扮演输入或*x*值的角色。

如果一个时间序列的是一个**独立且同分布的**（**IID**随机变量的序列![](img/B15439_09_005.png)，具有有限的均值和方差，则称之为**白噪声**。特别是，如果随机变量为正态分布，平均值为零，常数方差为![](img/B15439_09_006.png)，则该序列称为**高斯白噪声**。

如果时间序列可以写成过去扰动的加权和![](img/B15439_09_007.png)，则该时间序列是线性的，这些扰动也称为新息，在这里被假定为代表白噪声，并且序列的平均值![](img/B15439_04_005.png)：

![](img/B15439_09_009.png)

时间序列分析的一个关键目标是了解由系数![](img/B15439_09_010.png)驱动的动态行为。时间序列分析提供了适合此类数据的方法，目的是提取有用的模式，进而帮助我们建立预测模型。

为此，我们将介绍最重要的工具，包括关键系统元素的分解、自相关分析和滚动窗口统计（如移动平均）。

对于本章中的大多数示例，我们将使用美联储提供的数据，您可以使用 pandas datareader 访问这些数据，我们在*第 2 章*、*市场和基础数据–来源和技术*中介绍了这些数据。本节的代码示例可在笔记本`tsa_and_stationarity`中找到。

## 如何分解时间序列模式

时间序列数据通常包含可分解为多个组件的混合模式。特别是，时间序列通常结合了系统性成分，如趋势、季节性和周期以及非系统性噪声。这些分量可以建模为线性组合（例如，当波动不取决于序列的水平时）或非线性乘法形式。

根据模型假设，它们也可以自动拆分。Statsmodels 包括一种简单的方法，使用移动平均将时间序列拆分为单独的趋势、季节和剩余部分。我们可以将其应用于包含强劲趋势成分和季节性成分的工业制造业月度数据，如下所示：

```py
import statsmodels.tsa.api as tsa
industrial_production = web.DataReader('IPGMFN', 'fred', '1988', '2017-12').squeeze()
components = tsa.seasonal_decompose(industrial_production, model='additive')
ts = (industrial_production.to_frame('Original')
      .assign(Trend=components.trend)
      .assign(Seasonality=components.seasonal)
      .assign(Residual=components.resid))
ts.plot(subplots=True, figsize=(14, 8)); 
```

*图 9.1*显示了显示添加剂成分的结果图表。假设趋势和季节性成分更具确定性且易于简单外推，则剩余成分将是后续建模工作的重点：

![](img/15439_09_01.png)

图 9.1：时间序列分解为趋势、季节性和残差

还有更复杂的基于模型的方法，例如，见 Hyndman 和 Athanasopoulos（2018）中的*第 6 章*、*机器学习过程*。

## 滚动窗口统计和移动平均

给定时间序列数据的顺序，计算给定长度周期内熟悉的描述性统计是很自然的。目标是检测序列是否稳定或随时间变化，并获得平滑表示，在滤除噪声的同时捕获系统方面。

滚动窗口统计服务于这一过程：它们生成一个新的时间序列，其中每个数据点表示为原始数据的特定时段计算的汇总统计。移动平均线是最常见的例子。原始数据点可以使用相等的权重（例如，强调较新的数据点）进入计算。指数移动平均值递归计算权重，这些权重在过去会进一步衰减。新数据点通常是所有先前数据点的摘要，但也可以从周围的窗口计算它们。

pandas 库包括滚动或扩展窗口，并允许各种权重分布。在第二步中，您可以对窗口捕获的每组数据应用计算。这些计算包括单个序列的内置函数，如平均值或总和，以及多个序列的相关性或协方差，以及用户定义的函数。

我们在*第 4 章*、*金融特征工程——如何研究阿尔法因子*、以及*第 7 章*、*线性模型——从风险因子到回报预测*中使用了该功能来设计特征。下一节中的移动平均和指数平滑示例也将应用这些工具。

早期预测模型包括具有指数权重的**移动平均模型**称为**指数平滑模型**。我们将再次遇到移动平均线作为线性时间序列的关键构建块。依赖指数平滑方法的预测使用过去观测值的加权平均值，随着观测值变老，权重呈指数衰减。因此，最近的观察得到的相关权重更高。这些方法适用于没有非常复杂或突变模式的时间序列。

## 如何测量自相关

**自相关**（也称为*序列相关*）将相关概念与时间序列上下文相适应：正如相关系数衡量两个变量之间线性关系的强度一样，**自相关系数**、![](img/B15439_09_011.png)，测量由给定滞后*k*分隔的时间序列值之间的线性关系范围：

![](img/B15439_09_012.png)

因此，我们可以为长度为*T*的时间序列中的*T*-1 个滞后计算一个自相关系数。**自相关函数**（**ACF**计算相关系数作为滞后的函数。

大于 1 的滞后的自相关（即，观测之间相隔超过一个时间步）既反映了这些观测之间的直接相关性，也反映了中间数据点的间接影响。**偏自相关**消除了这种影响，仅测量给定滞后距离*T*下数据点之间的线性相关性。去除是指使用线性回归的残差与结果*x*<sub xmlns:epub="http://www.idpf.org/2007/ops" style="font-style: italic;">t</sub>和滞后值*x*<sub xmlns:epub="http://www.idpf.org/2007/ops" style="font-style: italic;">t</sub><sub xmlns:epub="http://www.idpf.org/2007/ops" class="Subscript--PACKT-">-1</sub>、*x*t<sub xmlns:epub="http://www.idpf.org/2007/ops" class="Subscript--PACKT-">-2</sub>、*x<sub xmlns:epub="http://www.idpf.org/2007/ops" style="font-style: italic;"><sub xmlns:epub="http://www.idpf.org/2007/ops" class="Subscript--PACKT-">t<sub xmlns:epub="http://www.idpf.org/2007/ops" class="Subscript--PACKT-">t<sub xmlns:epub="http://www.idpf.org/2007/ops" class="Subscript--PACKT-">t</sub>-1】的结果</sub>作为特征（也称为*AR*（*T*-1）模型，我们将在下一节单变量时间序列模型中讨论。）**偏自相关函数**（**PACF**）提供了所有如前所述，一旦在较短滞后时间内消除相关性的影响，就会产生相关性。</sub></sub>*

还有一些算法根据 PACF 和 ACF 之间的精确理论关系，从样本自相关估计偏自相关。

**相关图**只是连续滞后的 ACF 或 PACF 的图，*k*=0,1，*n*。它允许我们一眼就可以检查各滞后之间的相关性结构（参见*图 9.3*中的示例）。相关图的主要用途是在去除确定性趋势或季节性后检测任何自相关。ACF 和 PACF 都是设计线性时间序列模型的关键诊断工具，我们将在下一节时间序列转换中回顾 ACF 和 PACF 图的示例。

# 如何诊断并实现平稳性

统计特性，例如**平稳时间序列**的均值、方差或自相关，与周期无关，也就是说，它们不随时间变化。因此，**平稳性**意味着时间序列没有趋势或季节效应。此外，它要求在计算不同滚动窗口时，描述性统计数据（如平均值或标准偏差）保持不变或不会随时间发生显著变化。平稳时间序列恢复到其平均值，偏差具有恒定的振幅，而短期运动在统计意义上总是相似的。

更正式地说，**严格平稳性**要求时间序列观测值的任何子集相对于所有时刻的联合分布独立于时间。因此，除了均值和方差外，更高的矩，如偏斜和峰度，也需要保持不变，而不考虑不同观测之间的滞后。在大多数应用中，例如本章中我们可以用来建模资产收益的大多数时间序列模型，我们将平稳性限制为一阶矩和二阶矩，以便时间序列具有恒定均值、方差和自相关的协方差平稳性。然而，我们在构建波动性建模时放弃了这一假设，明确假设方差会以可预测的方式随时间变化。

请注意，我们特别考虑了不同滞后下输出值之间的**相关性，就像我们希望线性回归的输入数据与结果相关一样。平稳性意味着这些关系是稳定的。平稳性是经典统计模型的一个重要假设。以下两小节将介绍有助于使时间序列平稳的变换，以及如何解决由单位根引起的随机趋势的特殊情况。**

## 转换时间序列以实现平稳性

为了满足许多时间序列模型的平稳性假设，我们需要对原始序列进行变换，通常需要几个步骤。常见的转换包括（自然）**对数**到将指数增长模式转换为线性趋势并稳定方差。**通货紧缩**意味着将一个时间序列除以导致趋势行为的另一个序列，例如，将一个名义序列除以一个价格指数以将其转换为实际度量。

如果序列恢复为稳定的长期线性趋势，则序列**趋势稳定**。通常可以通过使用线性回归和残差拟合趋势线使其保持平稳。这意味着将时间指数作为自变量纳入线性回归模型，可能与测井或平减相结合。

在许多情况下，去趋势化不足以使序列静止。相反，我们需要将原始数据转换为一系列的**时段间和/或季节间差异**。换句话说，我们使用相邻数据点或季节性滞后值相互减去的结果。请注意，当将这种差异应用于对数转换序列时，结果表示金融环境中的瞬时增长率或回报。

如果一个单变量序列在差分*d*次后变为平稳，则称其为*d*阶的积分，或者如果*d*=1，则称其为简单积分。这种行为是由单位根引起的，我们将在下面解释。

## 处理而不是如何处理

单位根为确定使时间序列平稳的变换带来了一个特殊的问题。在讨论诊断测试和解决方案之前，我们将首先解释单位根的概念。

### 关于单位根和随机游动

时间序列通常被建模为以下自回归形式的随机过程，因此当前值是过去值加上随机扰动的加权和：

![](img/B15439_09_013.png)

在下一节单变量时间序列模型中，我们将更详细地探讨这些模型，作为 ARIMA 模型的 AR 构建块。该过程具有以下形式的特征方程：

![](img/B15439_09_014.png)

如果该多项式的（最多）*p*根之一等于 1，则该过程称为具有**单位根**。它将是非平稳的，但不一定有趋势。如果特征方程的剩余根的绝对值小于 1，则过程的第一个差分将是平稳的，**过程是 1 阶或 I（1）**阶的积分。如果附加根的绝对值大于 1，则积分的阶数更高，需要附加差分。

在实践中，利率或资产价格的时间序列通常不是固定的，因为没有一个价格水平可以恢复到该序列。非平稳序列最突出的例子是随机游动。给定一个价格*p*<sub style="font-style: italic;">t</sub>与起始价*p*<sub class="Subscript--PACKT-">0</sub>（例如股票的 IPO 价格）和白噪声扰动![](img/B15439_09_005.png)的时间序列，则随机游动满足以下自回归关系：

![](img/B15439_09_016.png)

重复替换表明，当前值*p*<sub style="font-style: italic;">t</sub>是之前所有干扰或创新![](img/B15439_09_005.png)和初始价格*p*<sub class="Subscript--PACKT-">0</sub>的总和。如果方程包含一个常数项，则称随机游动具有**漂移**。

因此，随机游动是以下形式的**自回归随机过程**：

![](img/B15439_09_018.png)

它具有单位根的特征方程![](img/B15439_09_019.png)，并且是非平稳的，并且是一阶积分。一方面，考虑到![](img/B15439_09_020.png)的 IID 性质，时间序列的方差等于![](img/B15439_09_021.png)，即**不是二阶平稳**，这意味着，原则上，该序列可以随时间假设任何值。另一方面，考虑到![](img/B15439_09_024.png)的统计假设，取**第一差**、![](img/B15439_09_022.png)后，留下![](img/B15439_09_023.png)，即**平稳**。

具有单位根的非平稳序列的定义特征是**长记忆**：因为当前值是过去干扰的总和，所以大的创新比均值回复的平稳序列持续更长的时间。

### 如何诊断单位根

统计单位根检验是客观确定是否需要（额外）差异的常用方法。这些是平稳性的统计假设检验，旨在确定是否需要差异。

**增广 Dickey-Fuller 检验**（**ADF 检验**）评估了无效假设，即时间序列样本有一个单位根，而不是平稳性的替代方案。它将时间趋势上的差分时间序列、第一个滞后和所有滞后差分进行回归，并根据滞后时间序列值上的系数值计算检验统计量。`statsmodels`易于实现（见笔记本`tsa_and_stationarity`。

形式上，时间序列的 ADF 测试![](img/B15439_09_025.png)运行线性回归，其中![](img/B15439_09_026.png)为常数，![](img/B15439_07_004.png)为时间趋势的系数，*p*为模型中使用的滞后数：

![](img/B15439_09_028.png)

约束![](img/B15439_09_029.png)表示随机游动，而只有![](img/B15439_09_030.png)表示带漂移的随机游动。滞后顺序通常使用*第 7 章**线性模型中引入的**Akaike 信息准则**（**AIC**）和**贝叶斯信息准则**（**BIC**）信息准则来确定。*

ADF 检验统计量使用样本系数![](img/B15439_09_031.png)，在单位根非平稳性的零假设下，该系数等于零，否则为负。它旨在证明，对于综合系列，滞后系列值不应在预测滞后差异之上和之外的第一个差异时提供有用的信息。

### 如何删除单位根并处理生成的序列

除了使用相邻数据点之间的差异来消除恒定的变化模式外，我们还可以应用**季节差异**来消除季节变化模式。这涉及到在代表季节模式长度的滞后距离处取值差。对于月度数据，这通常涉及滞后 12 的差异，对于季度数据，它涉及滞后 4 的差异，以消除季节性和线性趋势。

确定正确的变换，特别是差分的适当数量和滞后并不总是明确的。已经提出了一些**启发式**，可以总结如下：

*   Lag-1 自相关接近零或负，或自相关通常较小且无模式：不需要高阶差分
*   高达 10+滞后的正自相关：序列可能需要高阶差分
*   滞后-1 自相关
*   略微过差或欠差可以用 AR 或 MA 项进行校正（见下一节关于单变量时间序列模型）

一些作者推荐分数差分法作为一种更灵活的方法来呈现一个综合序列的平稳性，并且可能比简单的或季节性的离散间隔差分法能够保留更多的信息或信号。例如，参见 Marcos Lopez de Prado（2018）中的*第 5 章*、*投资组合优化和表现评估*。

## 实践中的时间序列变换

*图 9.2*中的图表显示了截至 2017 年的 30 年内纳斯达克股票指数和工业生产的时间序列的原始形式，以及应用对数和随后应用第一次和季节性差异（滞后 12）后的转换版本。

图表还显示了 ADF p 值，这允许我们在两种情况下的所有变换后拒绝单位根非平稳性假设：

![](img/15439_09_02.png)

图 9.2：时间序列转换和单位根测试结果

我们可以使用 Q-Q 图进一步分析转换序列的相关时间序列特征，该图将时间序列观测分布的分位数与正态分布的分位数以及基于 ACF 和 PACF 的相关图进行比较。

对于*图 9.3*中的纳斯达克曲线图，我们可以看到，虽然没有趋势，但方差不是恒定的，而是在 20 世纪 80 年代末、2001 年和 2008 年的市场动荡期间出现聚集峰值。Q-Q 图突出了分布的厚尾，极值比正态分布更频繁。

ACF 和 PACF 显示出相似的模式，在几个滞后处的自相关似乎是显著的：

![](img/15439_09_03.png)

图 9.3：转换后的纳斯达克综合指数的描述性统计

对于工业制造业生产的月度时间序列，我们可以看到 2008 年危机后的一个较大的负异常值，以及 Q-Q 图中相应的偏差（参见*图 9.4*。自相关系数远高于纳斯达克收益率，且平稳下降。PACF 在滞后 1 和 13 处显示出明显的正自相关模式，在滞后 3 和 4 处显示出显著的负系数：

![](img/15439_09_04.png)

图 9.4：转化工业生产数据的描述性统计

# 单变量时间序列模型

多元线性回归模型将感兴趣的变量表示为输入的线性组合加上随机干扰。相比之下，单变量时间序列模型将时间序列的当前值与序列的滞后值、当前噪声以及可能过去的噪声项的线性组合相关联。

指数平滑模型基于数据中趋势和季节性的描述，**ARIMA 模型旨在描述数据**中的自相关。ARIMA（*p*、*d*、*q*模型需要平稳性并利用两个构建块：

*   由时间序列的*p*滞后值组成的**自回归**（**AR**项）
*   包含*q*滞后扰动的**移动平均**（**MA**项）

**I**代表*积分*，因为该模型可以通过区分序列*d*次来解释单位根非平稳性。术语自回归强调 ARIMA 模型意味着时间序列对其自身值的回归。

我们将介绍 ARIMA 构建块、AR 和 MA 模型，并解释如何在**自回归移动平均**（**ARMA**）模型中将它们结合起来，该模型可以将串联积分解释为 ARIMA 模型，或者将外生变量包括为**AR（I）MAX**模型。此外，我们将说明如何包括季节性 AR 和 MA 术语，以扩展工具箱，使其也包括**SARMAX**模型。

## 如何建立自回归模型

顺序为*p*的 AR模型旨在捕捉不同滞后时间序列值之间的线性相关性，可以写成如下：

![](img/B15439_09_032.png)

这非常类似于对*y*<sub style="font-style: italic;">t</sub>滞后值的多元线性回归。该模型具有以下特征方程：

![](img/B15439_09_033.png)

*x*中的*p*次多项式解的逆是特征根，如果所有根的绝对值小于 1，则 AR（*p*过程是平稳的，否则不稳定。对于平稳序列，多步预测将收敛于序列的平均值。

我们可以使用熟悉的最小二乘法，使用*p*+1、*T*观测值来估计模型参数，以确保每个滞后项和结果都有数据。

### 如何确定滞后的数量

实际上，挑战包括确定滞后项的适当顺序*p*。我们在*如何测量自相关*一节中讨论的序列相关时间序列分析工具在做出这一决策时起着关键作用。

更具体地说，目视检查相关图通常会提供有用的线索：

*   **ACF**估计不同滞后时间的观测值之间的自相关，这反过来又是直接和间接线性相关的结果。因此，如果顺序为*k*的 AR 模型是正确的模型，ACF 将显示一个显著的序列相关性，直到滞后*k*，并且由于线性关系的间接效应导致的惯性，将延伸到后续滞后，直到随着效应减弱，它最终消失。
*   而**PACF**仅测量给定滞后间隔观测值之间的直接线性关系，因此它不会反映*k*以外滞后的相关性。

### 如何诊断模型拟合

如果模型正确地捕捉到滞后之间的线性相关性，那么残差应该类似于白噪声，并且 ACF 应该强调没有显著的自相关系数。

除了残差图，**Ljung Box Q 统计量**允许我们检验残差序列跟随白噪声的假设。无效假设是所有*m*序列相关系数均为零，而某些系数则为零。根据不同滞后*k*的样本自相关系数![](img/B15439_09_034.png)计算检验统计量，并遵循*X*<sup class="Superscript--PACKT-">2</sup>分布：

![](img/B15439_09_035.png)

正如我们将看到的，statsmodels 提供了关于不同滞后系数重要性的信息，不重要的系数应该被删除。如果 Q 统计量拒绝无自相关的零假设，则应该考虑附加的 AR 项。

## 如何建立移动平均线模型

MA（*q*模型使用*q*过去的扰动，而不是类似回归模型中时间序列的滞后值，如下所示：

![](img/B15439_09_036.png)

由于我们没有观察到白噪声干扰值，![](img/B15439_09_007.png)，MA（*q*）不是我们目前看到的回归模型。MA（*q*）模型不是使用最小二乘法，而是使用**最大似然法**（**最大似然法**）进行估计，或者在序列开始时初始化或估计扰动，然后递归迭代地计算余数。

MA（*q*模型的名称来源于将*y*<sub style="font-style: italic;">t</sub>的每个值表示为过去*q*创新的加权移动平均值。换句话说，当前估算代表了相对于模型过去错误的修正。MA（*q*模型）中移动平均值的使用不同于指数平滑或季节性时间序列成分的估计，因为 MA（*q*模型旨在预测未来值，而不是去噪或估计过去值的趋势周期。

MA（*q*过程）始终是平稳的，因为它们是白噪声变量的加权和，而白噪声变量本身是平稳的。

### 如何确定滞后的数量

an MA（*q*过程）生成的时间序列由先前*q*模型预测的残差驱动。因此，MA（*q*过程的 ACF 将显示滞后*q*的值的重要系数，然后急剧下降，因为这是模型假设序列值产生的方式。

请注意，这与我们刚才描述的 AR 情况有多大不同，在 AR 情况下，PACF 将显示类似的模式。

### AR 模型与 MA 模型的关系

AR（*p*模型始终可以表示为使用重复替换的![](img/B15439_09_038.png)过程，如*如何处理单位根*部分中的随机游走示例所示。

当 MA（*q*过程的系数满足一定的尺寸约束时，它也变得可逆，可以表示为![](img/B15439_09_039.png)过程（详见 Tsay，2005）。

## 如何建立 ARIMA 模型和扩展

自回归综合移动平均 ARIMA（*p*、*d*、*q*）模型结合 AR（*p*）和 MA（*q*过程，利用这些构建模块的互补性，简化模型开发。它们使用更紧凑的形式来实现这一点，并减少了参数的数量，从而降低了过度拟合的风险。

该模型还通过使用时间序列值的*d*<sup class="Superscript--PACKT-">th</sup>差来消除单位根非平稳性。ARIMA（*p*、1、*q*）模型与使用 ARMA（*p*、*q*）模型相同，具有系列的第一个差异。用*y*表示非季节性差分*d*次后的原始序列，ARIMA（*p*、*d*、*q*模型简单如下：

![](img/B15439_09_040.png)

ARIMA 模型也使用最大似然估计（MLE）进行估计。根据实现情况，高阶模型通常可以包含低阶模型。

例如，在版本 0.11 之前，statsmodels 包含所有低阶*p*和*q*项，并且不允许移除低于最高值的滞后系数。在这种情况下，高阶模型总是更适合。小心不要使用过多的术语使模型与数据过度匹配。最新版本在撰写本文时为 0.11，添加了一个实验性的新 ARIMA 模型，具有更灵活的配置选项。

### 如何建立差分级数模型

在使用数据时，也有设计单变量时间序列模型的指南：

*   无差分模型假设原始序列是平稳的，包括均值回复。它通常包括一个常数项，以允许非零平均值。
*   一阶差分模型假设原始序列具有恒定趋势，因此应包含恒定项。
*   具有两阶差分的模型假设原始序列具有时变趋势，且不应包含常数。

### 如何识别 AR 和 MA 术语的数量

由于 AR（*p*和 MA（*q*术语相互作用，ACF 和 PACF 提供的信息不再可靠，只能作为起点使用。

传统上，在选择模型设计时，AIC 和 BIC 信息标准一直依赖于样本拟合。或者，我们可以依靠样本外测试来交叉验证多个参数选择。

以下总结提供了在单独考虑 AR 和 MA 模型的情况下如何选择模型顺序的一些指导：

*   PACF 切断的滞后时间超过了 AR 项的指示数量。如果差分序列的 PACF 急剧下降和/或滞后 1 自相关为正，则添加一个或多个 AR 项。
*   超出 ACF 切断的滞后是指示的 MA 项数。如果差分系列的 ACF 显示锐截止和/或 LAG-1 自相关是负的，考虑将 MA 项添加到模型中。
*   AR 和 MA 项可能会抵消彼此的影响，因此，如果您的模型同时包含 AR 和 MA 项，请始终尝试将 AR 和 MA 项的数量减少 1，以避免过度拟合，尤其是当更复杂的模型需要 10 次以上迭代才能收敛时。
*   如果 AR 系数总和接近 1，并表示模型 AR 部分中有一个单位根，则消除一个 AR 项，并将模型差一次（再次）。
*   如果 MA 系数总和接近 1，并表明模型 MA 部分中存在单位根，则消除一个 MA 项，并将差分阶数减少一。
*   不稳定的长期预测表明，模型的 AR 或 MA 部分可能存在单位根。

### 添加功能–ARMAX

具有外部输入的**自回归移动平均模型**（**ARMAX**模型）在 ARMA 时间序列模型的右侧添加输入变量或协变量（假设序列是平稳的，因此我们可以跳过差分）：

![](img/B15439_09_041.png)

这类似于线性回归模型，但很难解释。这是因为![](img/B15439_09_042.png)对*y*<sub style="font-style: italic;">t</sub>的影响不是线性回归中*x*<sub style="font-style: italic;">t</sub>增加一个单位的影响。相反，等式右侧存在*y*<sub style="font-style: italic;">t</sub>的滞后值，这意味着系数只能解释为，因为响应变量的滞后值很难直观。

### 添加季节性差异–SARIMAX

对于具有季节效应的时间序列，我们可以包括 AR 和 MA 项，它们捕捉季节性的周期性。例如，当使用月度数据且季节效应长度为 1 年时，季节 AR 和MA 项将反映该特定滞后长度。

ARIMAX（*p*、*d*、*q*）模型随后成为 SARIMAX（*p*、*d*、*q*×（*p*、*d*、*q*）模型，编写起来有点复杂，但 statsmodels 文档（参见 GitHub 上的链接）提供了详细信息。

现在，我们将使用宏观数据构建一个季节性 ARMA 模型，以说明其实现。

## 如何预测宏观基本面

我们将为 1988-2017 年期间工业生产时间序列的月度数据建立一个 SARIMAX 模型。如分析工具的第一节所示，数据经过对数转换，我们使用的是季节性（滞后 12）差异。我们使用 10 年的滚动窗口训练数据对一系列普通和常规 AR 和 MA 参数的模型进行估计，并评估一步预测的**均方根误差**（**RMSE**），如以下简化代码所示（详见笔记本`arima_models`：

```py
for p1 in range(4):                # AR order
    for q1 in range(4):            # MA order
        for p2 in range(3):        # seasonal AR order
            for q2 in range(3):    # seasonal MA order
                y_pred = []
                for i, T in enumerate(range(train_size, len(data))):
                    train_set = data.iloc[T - train_size:T]
                    model = tsa.SARIMAX(endog=train_set, # model specification
                                        order=(p1, 0, q1),
                                        seasonal_order=(p2, 0, q2, 12)).fit()
                    preds.iloc[i, 1] = model.forecast(steps=1)[0]
                mse = mean_squared_error(preds.y_true, preds.y_pred)
                results[(p1, q1, p2, q2)] = [np.sqrt(mse),
                    preds.y_true.sub(preds.y_pred).std(),
                    np.mean(aic)] 
```

我们还收集了 AIC 和 BIC 标准，它们显示了非常高的秩相关系数 0.94，BIC 倾向于比 AIC 参数稍少的模型。RMSE 最好的五种型号是：

```py
 RMSE         AIC         BIC
p1 q1 p2 q2                                  
2  3  1  0   0.009323 -772.247023 -752.734581
3  2  1  0   0.009467 -768.844028 -749.331586
2  2  1  0   0.009540 -770.904835 -754.179884
   3  0  0   0.009773 -760.248885 -743.523935
   2  0  0   0.009986 -758.775827 -744.838368 
```

我们重新估计了 SARIMA（2,0,3）×（1,0,0）模型，如下所示：

```py
best_model = tsa.SARIMAX(endog=industrial_production_log_diff, order=(2, 0, 3),
                         seasonal_order=(1, 0, 0, 12)).fit()
print(best_model.summary()) 
```

我们得到以下总结：

![](img/15439_09_05.png)

图 9.5:SARMAX 模型结果

系数是显著的，Q 统计量拒绝了进一步自相关的假设。相关图同样表明，我们已成功消除了序列的自相关：

![](img/15439_09_06.png)

图 9.6:SARIMAX 模型诊断

## 如何使用时间序列模型预测波动性

单变量时间序列模型在金融领域的一个特别重要的应用是对波动性的预测。这是因为，随着时间的推移，波动率通常不是恒定不变的，而是一系列波动率聚集在一起。方差的变化给使用假定平稳性的经典 ARIMA 模型进行时间序列预测带来了挑战。为了应对这一挑战，我们现在将对波动性进行建模，以便预测方差的变化。

异方差性是指变量方差变化的技术术语。ARCH 模型将误差项的方差表示为前期误差的函数。更具体地说，它假设误差方差遵循 AR（*p*模型。

**广义自回归条件异方差**（**GARCH**）模型扩大了 ARCH 的范围，允许使用 ARMA 模型。时间序列预测通常将 ARIMA 模型与 ARCH/GARCH 模型结合用于预测时间序列的期望均值和期望方差。2003 年诺贝尔经济学奖授予罗伯特·恩格尔（Robert Engle）和克莱夫·格兰杰（Clive Granger），因为他们开发了这类模型。前者还负责纽约大学斯特恩学院的波动性实验室（[vlab.Stern.nyu.edu](http://vlab.stern.nyu.edu)），该实验室有许多与我们将讨论的模型相关的在线示例和工具。

### ARCH 模型

ARCH（*p*模型只是一个 AR（*p*模型，它应用于时间序列模型的残差方差，这使得在*t*时刻的方差取决于方差的滞后观测。

更具体地说，误差项![](img/B15439_09_043.png)是线性模型（如 ARIMA）在原始时间序列上的残差，并被分解为与时间相关的标准偏差![](img/B15439_09_044.png)和扰动*z*<sub style="font-style: italic;">t</sub>，如下所示：

![](img/B15439_09_045.png)

ARCH（*p*模型）可以使用 OLS 进行估计。Engle 提出了一种使用拉格朗日乘数检验确定适当拱阶的方法，该方法对应于线性回归中所有系数均为零的假设的 F 检验（参见*第 7 章*、*线性模型——从风险因子到回报预测*。

ARCH 模型的一个关键**强度**是，它产生了具有正超额峰度的波动性估计——即相对于正态分布的厚尾——这反过来又与关于收益的经验观察结果相一致。**弱点**包括对正波动性冲击和负波动性冲击具有相同影响的假设，而资产价格的反应往往不同。它也不能解释波动性的变化，并且可能会高估波动性，因为它们对收益率序列的大型孤立冲击反应缓慢。

对于适当指定的 ARCH 模型，标准化残差（除以标准偏差期间的模型估计值）应类似于白噪声，并可进行 Ljung-Box Q 测试。

### 广义 ARCH——GARCH 模型

ARCH 模型相对简单，但通常需要许多参数来捕捉资产收益率序列的波动模式。GARCH 模型适用于日志返回序列*r*<sub style="font-style: italic;">t</sub>，带有干扰![](img/B15439_09_046.png)，遵循 GARCH（*p*、*q*模型，如果：

![](img/B15439_09_047.png)

GARCH（*p*、*q*模型假设误差项的方差为 ARMA（*p*、*q*模型，![](img/B15439_09_048.png)。

与 ARCH 模型类似，GARCH（1,1）过程的尾部分布比正态分布的尾部分布重。该模型遇到与 ARCH 模型相同的弱点。例如，它对积极和消极冲击的反应是相同的。

要配置 ARCH 和 GARCH 模型的滞后顺序，请使用经过训练的时间序列的平方残差来预测原始序列的平均值。残差以零为中心，因此它们的平方也是方差。然后，检查平方残差的 ACF 和 PACF 图，以识别时间序列方差中的自相关模式。

### 如何建立预测波动性的模型

资产收益率系列波动率模型的开发包括四个步骤：

1.  基于 ACF 和 PACF 揭示的序列相关性，建立金融时间序列的 ARMA 时间序列模型
2.  测试 ARCH/GARCH 效应模型的残差，再次依赖残差平方序列的 ACF 和 PACF
3.  如果序列相关效应显著，则指定波动率模型，并联合估计平均值和波动率方程
4.  仔细检查安装的型号，必要时对其进行改进

将波动率预测应用于收益率序列时，序列相关性可能受到限制，因此可以使用常数平均值代替 ARMA 模型。

`arch`库（参见 GitHub 上文档的链接）提供了几种估计波动率预测模型的选项。如*如何建立自回归模型*一节中所述，您可以将预期平均值建模为一个常数，即 AR（*p*模型，或更近期的**异质自回归过程**（**HAR**，该过程使用每天（1 天）、每周（5 天）和每月（22 天）的滞后时间捕捉短期、中期和长期投资者的交易频率。

均值模型可以与几个条件异方差模型联合定义和估计，这些模型除了 ARCH 和 GARCH 之外，还包括**指数 GARCH**（**EGARCH**）模型，该模型允许正收益和负收益之间的不对称效应，以及**异方差 ARCH**（**HARCH**模型，补充了 HAR 均值模型。

我们将使用 2000-2020 年的每日纳斯达克收益率来演示 GARCH 模型的使用（详情请参见笔记本`arch_garch_models`：

```py
nasdaq = web.DataReader('NASDAQCOM', 'fred', '2000', '2020').squeeze()
nasdaq_returns = np.log(nasdaq).diff().dropna().mul(100) # rescale to facilitate optimization 
```

经重定标的日收益率序列仅表现出有限的自相关，但与平均值的平方偏差确实具有实质性的记忆，反映在缓慢衰减的 ACF 和 PACF 中，前两个 ACF 和 PACF 都很高，仅在前六个滞后后才被切断：

```py
plot_correlogram(nasdaq_returns.sub(nasdaq_returns.mean()).pow(2), lags=120,                  title='NASDAQ Daily Volatility') 
```

函数`plot_correlogram`产生以下输出：

![](img/15439_09_07.png)

图 9.7：每日纳斯达克综合波动率

因此，我们可以估计一个 GARCH 模型来捕捉过去波动率的线性关系。我们将使用滚动10 年窗口来估计一个 GARCH（*p*、*q*）模型，其中*p*和*q*范围为 1-4，以生成一步出样本预测。

然后，我们将预测波动率的 RMSE 与其平均回报率的实际平方偏差进行比较，以确定最具预测性的模型。我们使用 winsorized 数据来限制极端回报值的影响，这些极端回报值反映在波动率的非常高的正偏斜中：

```py
trainsize = 10 * 252  # 10 years
data = nasdaq_returns.clip(lower=nasdaq_returns.quantile(.05),
                           upper=nasdaq_returns.quantile(.95))
T = len(nasdaq_returns)
results = {}
for p in range(1, 5):
    for q in range(1, 5):
        print(f'{p} | {q}')
        result = []
        for s, t in enumerate(range(trainsize, T-1)):
            train_set = data.iloc[s: t]
            test_set = data.iloc[t+1]  # 1-step ahead forecast
            model = arch_model(y=train_set, p=p, q=q).fit(disp='off')
            forecast = model.forecast(horizon=1)
            mu = forecast.mean.iloc[-1, 0]
            var = forecast.variance.iloc[-1, 0]
            result.append([(test_set-mu)**2, var])
        df = pd.DataFrame(result, columns=['y_true', 'y_pred'])
        results[(p, q)] = np.sqrt(mean_squared_error(df.y_true, df.y_pred)) 
```

GARCH（2，2）模型的 RMSE 最低（与 GARCH（4，2）的值相同，但参数较少），因此我们继续估计该模型以检查总结：

```py
am = ConstantMean(nasdaq_returns.clip(lower=nasdaq_returns.quantile(.05),
                                      upper=nasdaq_returns.quantile(.95)))
am.volatility = GARCH(2, 0, 2)
am.distribution = Normal()
best_model = am.fit(update_freq=5)
print(best_model.summary()) 
```

输出显示了最大化的对数似然，以及 AIC 和 BIC 标准，在基于样本内表现选择模型时，这些标准通常被最小化（参见*第 7 章*、*线性模型–从风险因子到回报预测*。它还显示了平均模型的结果，在这种情况下，平均模型只是一个常数估计，以及常数ω的 GARCH 参数、AR 参数![](img/B15439_09_049.png)和 MA 参数![](img/B15439_09_050.png)，所有这些参数都具有统计显著性：

![](img/15439_09_08.png)

图 9.8:GARCH 模型结果

现在，让我们探讨多时间序列的模型和协整的概念，这将支持新的交易策略。

# 多元时间序列模型

多变量时间序列模型旨在同时捕获多个时间序列的动态，并利用这些序列之间的相关性进行更可靠的预测。对这一主题最全面的介绍是吕特克波尔（2005）。

## 方程组

单变量时间序列模型，就像我们刚才讨论的 ARMA 方法一样，在 ARMAX 的情况下，仅限于目标变量与其滞后值或滞后干扰与外生序列之间的统计关系。相比之下，多元时间序列模型也允许其他时间序列的滞后值影响目标。此效果适用于所有系列，导致复杂的交互，如下图所示：

![](img/15439_09_09.png)

图 9.9：单变量和多变量时间序列模型中的相互作用

除了潜在的更好的预测之外，多元时间序列还可用于深入了解跨序列相关性。例如，在经济学中，多变量时间序列用于理解一个变量（如利率）的政策变化如何在不同时期影响其他变量。

多变量模型产生的**脉冲响应**函数可用于此目的，并允许我们模拟一个变量如何响应其他变量的突然变化。**格兰杰因果关系**的概念分析一个变量在预测另一个变量时是否有用（在最小二乘意义上）。此外，多元时间序列模型允许对预测误差方差进行分解，以分析其他序列的贡献。

## 向量自回归（VAR）模型

我们将看到**向量自回归 VAR（p）模型**如何通过创建一个*k*方程组系统，将 AR（*p*模型扩展到*k*系列，其中每个方程组包含所有*k*系列的*p*滞后值。在最简单的情况下，*k*=2 的 VAR（1）模型采用以下形式：

![](img/B15439_09_051.png)

该模型可以用**矩阵形式**更简洁地表达：

![](img/B15439_09_052.png)

输出滞后值上的**系数**提供了有关序列本身动力学的信息，而交叉变量系数则提供了对序列间相互作用的一些见解。此符号扩展到*k*时间序列和顺序*p*，如下所示：

![](img/B15439_09_053.png)

VAR（*p*模型也需要**平稳性**以便单变量时间序列建模的初始步骤得以延续。首先，探索该系列并确定必要的转换。然后，应用增强的 Dickey-Fuller 检验来验证每个序列是否满足平稳性标准，否则应用进一步的变换。它可以用初始信息条件下的 OLS 或 MLE 进行估计，MLE 与正态分布误差等效，但不适用于其他情况。

如果*k*系列的部分或全部是单位根非平稳的，则它们可能是**协整的**（见下一节）。单位根概念对多个时间序列的扩展意味着两个或多个序列的线性组合是平稳的，因此，均值回复。

VAR 模型不具备在无差异的情况下处理这种情况的能力；相反，使用**矢量误差修正模型**（**VECM**、约翰森和朱塞利乌斯 1990）。我们将进一步探讨协整，因为如果存在并假设其持续存在，它可以用于配对交易策略。

**对滞后顺序**的确定也从每个系列的 ACF 和 PACF 中获取线索，但受相同滞后顺序适用于所有系列这一事实的约束。在模型估计之后，**残差诊断**也需要类似于白噪声的结果，模型选择可以使用样本信息标准，或者，如果目标是使用模型进行预测，则可以使用样本外预测性能来交叉验证替代模型设计。

正如在单变量情况中提到的，原始时间序列的预测要求我们在训练模型之前反转用于使序列平稳的变换。

## 使用 VAR 模型进行宏观预测

我们将扩展单变量示例，使用工业生产月度数据的单一时间序列，并添加消费者情感的月度时间序列，这两个时间序列均由美联储的数据服务提供。我们将使用熟悉的 pandas datareader 库检索 1970 年至 2017 年的数据：

```py
df = web.DataReader(['UMCSENT', 'IPGMFN'],
                     'fred', '1970', '2017-12').dropna()
df.columns = ['sentiment', 'ip'] 
```

对工业生产系列进行对数变换，并对两个系列使用 12 的滞后进行季节性差分，得出平稳结果：

```py
df_transformed = pd.DataFrame({'ip': np.log(df.ip).diff(12),
                              'sentiment': df.sentiment.diff(12)}).dropna()
test_unit_root(df_transformed) # see notebook for details and additional plots
          p-value
ip          0.0003
sentiment   0.0000 
```

这就给我们留下了以下系列：

![](img/15439_09_10.png)

图 9.10：转换后的时间序列：工业生产和消费者情感

为了限制输出的大小，我们将仅使用 statsmodels`VARMAX`实现（允许可选的外生变量）估算 VAR（1）模型，并使用前 480 个观察值以恒定趋势进行估算：

```py
model = VARMAX(df_transformed.loc[:'2017'], order=(1,1),
               trend='c').fit(maxiter=1000) 
```

这将产生以下总结：

![](img/15439_09_11.png)

图 9.11:VAR（1）模型结果

输出包含两个时间序列方程的系数，如前面的 VAR（1）说明所述。statsmodels 提供诊断图，以检查残差是否符合白噪声假设。在这个简单的例子中，情况并非如此，因为方差似乎不是常数（左上角），分位数图显示了分布的差异，即厚尾（左下角）：

![](img/15439_09_12.png)

图 9.12:statsmodels VAR 模型诊断图

您可以生成样本外预测，如下所示：

```py
preds = model.predict(start=480, end=len(df_transformed)-1) 
```

以下实际值和预测值的可视化显示了预测如何滞后于实际值，并且无法很好地捕捉非线性样本外模式：

![](img/15439_09_13.png)

图 9.13:VAR 模型预测与实际值

# 协整-具有共同趋势的时间序列

我们在前面关于多元时间序列模型的章节中简要提到了协整。现在，让我们解释一下这个概念，以及在将其用于统计套利交易策略之前，如何更详细地诊断它的存在。

我们已经看到了时间序列如何有一个单位根来创建随机趋势，并使时间序列高度持久化。当我们在线性回归模型中使用这种原始形式的集成时间序列而不是差分形式的时间序列作为特征时，其与结果的关系通常会出现统计显著性，即使它不是。这种现象被称为虚假回归（详见《金融时间序列和卫星图像》的*第 18 章*、*CNNs，Wooldridge，2008）。因此，建议的解决方案是对时间序列进行差分，使其在模型中使用之前变得平稳。*

然而，当结果与一个或多个输入变量之间存在协整关系时，则有例外。为了理解协整的概念，让我们首先记住回归模型的残差是输入和输出序列的线性组合。

通常，一个集成时间序列在一个或多个此类序列上的回归残差会产生非平稳残差，这些残差也是集成的，因此表现为随机游动。然而，对于某些时间序列，情况并非如此：回归产生的系数以平稳残差的形式产生时间序列的线性组合，即使单个序列不是。这些时间序列是*协整的*。

一个非技术性的例子是一个醉汉在他的狗（用皮带）的陪同下随意散步。这两条轨迹都是非平稳的，但是协整的，因为狗偶尔会回到主人身边。在交易环境中，套利约束意味着现货和期货价格之间的协整关系。

换句话说，两个或多个协整序列的**线性组合有一个稳定的平均值**，该线性组合将恢复到该平均值。这也适用于单个系列以更高阶进行积分，而线性组合降低了整体积分阶数的情况。

**协整与相关**不同：两个序列可以高度相关，但不需要协整。例如，如果两个增长序列是彼此的常数倍数，它们的相关性将很高，但任何线性组合也将增长，而不是恢复到稳定的平均值。

协整非常有用：如果两个或两个以上的资产价格序列倾向于恢复到一个共同的平均值，我们可以利用趋势的偏差，因为它们应该意味着未来的价格变动方向相反。协整背后的数学更为复杂，因此我们将只关注实践方面；关于深入的治疗，见吕特凯波尔（2005 年）。

在本节中，我们将讨论如何识别具有长期平稳关系的对，估计纠正任何不平衡的预期时间，以及如何利用这些工具实施和回溯测试长短对交易策略。

共整检验有两种方法：

*   恩格尔-格兰杰两步法
*   约翰森测验

在我们展示它们如何帮助识别趋向于回归到共同趋势的协整证券之前，我们将依次讨论每种证券，这是我们可以利用的统计套利策略。

## 恩格尔-格兰杰两步法

采用**恩格尔-格兰杰方法**识别两个序列之间的协整关系。它涉及以下两个方面：

1.  将一个序列回归到另一个序列以估计平稳的长期关系
2.  对回归残差应用 ADF 单位根检验

零假设是残差有一个单位根并且是积分的；如果我们可以拒绝它，那么我们假设残差是平稳的，因此序列是协整的（Engle 和 Granger 1987）。

这种方法的一个主要优点是回归系数表示使组合保持平稳的乘数，即均值回复。不幸的是，测试结果会有所不同，这取决于我们考虑独立的变量，因此我们尝试两种方式，然后选择与具有较低 p 值的更负的检验统计量的关系。

另一个缺点是，该测试仅限于成对关系。更复杂的 Johansen 过程可以识别多达十几个时间序列之间的显著协整关系。

## 约翰森似然比检验

相反，**Johansen 程序**测试协整对 VAR 模型施加的限制，如前一节所述。更具体地说，从通用 VAR（*p*模型）两侧减去目标向量后，我们得到**误差修正模型**（**ECM**公式：

![](img/B15439_09_054.png)

由此产生的修正 VAR（*p*方程在层级（*y*<sub style="font-style: italic;">t</sub><sub class="Subscript--PACKT-">-1</sub>）中只有一个向量项，不使用![](img/B15439_09_055.png)运算符表示为差。协整的性质取决于该术语的系数矩阵![](img/B15439_09_056.png)的等级（Johansen 1991）。

虽然该方程在结构上与 ADF 测试设置类似，但由于涉及多个系列，因此现在有几个共同趋势的潜在星座。为了确定协整关系的数量，Johansen 检验从 0（无协整）开始，连续测试![](img/B15439_09_057.png)的递增等级。在下一节中，我们将探讨两个系列案例的应用。

Gonzalo 和 Lee（1998）讨论了由于错误指定的模型动力学和其他实现方面而带来的实际挑战，包括如何结合我们将在下一节中用于样本统计套利策略的两个测试程序。

# 协整统计套利

统计套利是指利用某种统计模型或方法，在保持一定程度的市场中立性的同时，利用资产相对错误定价的策略。

**配对交易**是一种概念上简单的策略，算法交易员至少在 80 年代中期就开始采用这种策略（Gatev、Goetzmann 和 Rouwenhorst，2006）。我们的目标是找到两种资产，它们的价格在历史上一直在一起变动，跟踪价差（它们价格之间的差异），一旦价差扩大，买入跌破共同趋势的输家，做空赢家。如果这种关系持续存在，随着价格趋同和头寸平仓，多头和/或短头交易将带来利润。

该方法通过从多个证券中形成篮子，并将一项资产与一篮子两个篮子相互交易，从而扩展到多变量环境。

实际上，该战略需要两个步骤：

1.  **形成阶段**：识别具有长期均值回复关系的证券。理想情况下，利差应具有较高的方差，以允许频繁的有利可图交易，同时可靠地恢复到共同趋势。
2.  **交易阶段**：触发进入和退出交易规则，因为价格波动导致价差发散和收敛。

在过去几年中，通过对多个资产类别在该领域日益活跃的研究，出现了几种形成和交易阶段的方法。在深入研究示例应用程序之前，下一小节将概述关键区别。

## 如何选择和交易移动资产对

最近对 pairs 交易策略的全面调查（Krauss 2017）确定了四种不同的方法，以及其他一些较新的方法，包括基于 ML 的预测：

*   **距离法**：最古老且研究最多的方法使用距离度量（如相关性）识别候选对，并使用非参数阈值（如布林带）触发进入和退出交易。自 Gatev 等人（2006 年）以来，其计算简单性允许大规模应用程序在较长时间内跨市场和资产类别显示盈利能力。然而，最近业绩有所下降。
*   **协整方法**：如之前所述，该方法依赖于两个或多个变量之间长期关系的计量经济学模型，并允许进行比简单距离度量更可靠的统计测试。这类示例使用 Engle Granger 和 Johansen 程序来识别证券对和证券篮子，以及旨在捕获该概念的更简单的启发式方法（Vidyamurthy 2004）。交易规则通常类似于距离度量使用的简单阈值。
*   **时间序列法**：这类策略以为重点，将利差建模为均值回复随机过程，并相应优化进入和退出规则（Elliott、Hoek 和 Malcolm，2005）。它假设有希望的配对已经被确定。
*   **随机控制方法**：与时间序列方法类似，目标是使用随机控制理论优化交易规则，以找到价值和政策函数，从而得出最优投资组合（Liu 和 Timmermann 2013）。我们将在*第 21 章*、*合成时间序列数据生成对抗网络*中讨论这种方法。
*   **其他方法**：除了基于无监督学习的配对识别，如主成分分析（见*第 13 章*、*数据驱动的风险因子和无监督学习的资产配置*）和统计模型，如 copulas（Patton 2012），最近，机器学习越来越流行，可以根据相对价格或回报预测来识别配对（Huck 2019）。我们将介绍几种可用于此目的的 ML 算法，并在接下来的章节中说明相应的多元对交易策略。

这一对各种方法的总结几乎不能让我们一窥成对交易策略设计所提供的灵活性。除了关于对选择和交易规则逻辑的更高层次的问题外，还有**大量的参数**需要**定义以实现**。这些参数包括：

*   用于筛选潜在投资组合或篮子的投资宇宙
*   形成期的长度
*   用于选择可交易候选人的关系强度
*   偏离和趋同于其常用手段的程度，以触发进入或退出交易，或在利差波动时调整现有头寸

## 实践中的成对交易

**距离法**使用（标准化）资产价格或其收益的相关性来识别配对，与协整检验相比，该方法简单且计算强度低几个数量级。笔记本`cointegration_test`以约 150 只股票为样本，用 4 年的每日数据说明了这一点：计算与 ETF 收益率的相关性需要约 30 秒，而一系列协整测试（使用 statsmodels）需要 18 秒——慢 600 倍。

**速度优势**特别有价值。这是因为潜在对的数量是双方考虑的候选数量的乘积，因此评估 100 只股票和 100 只 ETF 的组合需要比较 10000 次测试（我们将在后面讨论多重测试偏差的挑战）。

另一方面，距离度量不一定选择最赚钱的对：相关性被最大化以实现完美的协同运动，这反过来又消除了实际的交易机会。实证研究证实，协整对价格差的波动性几乎是距离对价格差波动性的两倍（Huck 和 Afawubo，2015）。

为了平衡**计算成本和结果对**质量之间的权衡，Krauss（2017）根据其文献综述推荐了一种结合两种方法的程序：

1.  选择具有稳定排列且几乎没有漂移的配对，以减少候选数量
2.  测试具有最高利差方差的剩余对进行协整

该过程旨在选择具有较低分歧风险的协整对，同时确保波动性较大的利差，从而产生较高的利润机会。

大量测试引入**数据窥探偏差**，如*第 6 章**机器学习过程*中所述：*多次测试可能会增加误报的数量，从而错误地拒绝无协整的无效假设。虽然统计显著性可能不是盈利交易所必需的（Chan 2008），但根据 Romano 和 Wolf（2010），对商品对（康明斯和 Bucca 2012）的研究表明，控制家族性错误率以提高测试的能力可以带来更好的表现。*

在下一小节中，我们将更深入地了解资产价格共同变动程度的各种启发式方法对协整检验结果的预测效果。

示例代码使用了纽约证交所和纳斯达克交易的 172 只股票和 138 只 ETF 样本，以及 Stooq 提供的 2010-2019 年的每日数据。

这些证券代表其各自类别样本期内最大的平均美元交易量；高度相关的固定资产已被移除。有关如何获取数据的说明，请参见 GitHub 存储库`data`文件夹中的笔记本`create_datasets`，相关代码以及其他预处理和探索细节，请参见笔记本`cointegration_tests`。

### 基于距离的启发式算法寻找协整对

`compute_pair_metrics()`计算了 2010-14 年和 2015-19 年超过 23000 对股票和**交易所买卖基金**（**ETF**）的以下距离指标：

*   价差的**漂移，定义为价差上时间趋势的线性回归**
*   **价差波动性**
*   标准化价格序列及其收益之间的**相关性**

低漂移和波动以及高相关性是协整的简单代表。

为了评估这些启发式方法的预测能力，我们还对前面的两对样本使用 statsmodels 进行了**Engle-Granger 和 Johansen 协整**检验。这发生在`compute_pair_metrics()`下半部分的循环中。

我们首先估计需要为 Johansen 测试指定的最佳滞后数。对于这两个测试，我们假设协整序列（利差）的截距可能不同于零，但没有趋势：

```py
def compute_pair_metrics(security, candidates):
    security = security.div(security.iloc[0])
    ticker = security.name
    candidates = candidates.div(candidates.iloc[0])
    # compute heuristics
    spreads = candidates.sub(security, axis=0)
    n, m = spreads.shape
    X = np.ones(shape=(n, 2))
    X[:, 1] = np.arange(1, n + 1)
    drift = ((np.linalg.inv(X.T @ X) @ X.T @ spreads).iloc[1]
             .to_frame('drift'))
    vol = spreads.std().to_frame('vol')
    corr_ret = (candidates.pct_change()
                .corrwith(security.pct_change())
                .to_frame('corr_ret'))
    corr = candidates.corrwith(security).to_frame('corr')
    metrics = drift.join(vol).join(corr).join(corr_ret).assign(n=n)
    tests = []
    # compute cointegration tests
    for candidate, prices in candidates.items():
        df = pd.DataFrame({'s1': security, 's2': prices})
        var = VAR(df)
        lags = var.select_order() # select VAR order
        k_ar_diff = lags.selected_orders['aic']
        # Johansen Test with constant Term and estd. lag order
        cj0 = coint_johansen(df, det_order=0, k_ar_diff=k_ar_diff)
        # Engle-Granger Tests
        t1, p1 = coint(security, prices, trend='c')[:2]
        t2, p2 = coint(prices, security, trend='c')[:2]
        tests.append([ticker, candidate, t1, p1, t2, p2, 
                      k_ar_diff, *cj0.lr1])

    return metrics.join(tests) 
```

为了检验协整检验的**显著性，我们将秩 0 和秩 1 的 Johansen 迹统计量与各自的临界值进行比较，并获得 Engle-Granger p 值。**

我们遵循上一节末尾提到的 Gonzalo 和 Lee（1998）的建议，应用两种测试并在他们同意的情况下接受配对。作者建议在出现分歧时进行额外的尽职调查，我们将跳过：

```py
spreads['trace_sig'] = ((spreads.trace0 > trace0_cv) &
                        (spreads.trace1 > trace1_cv)).astype(int)
spreads['eg_sig'] = (spreads.p < .05).astype(int) 
```

对于两个样本期内超过 46000 对样本，Johansen 检验认为 3.2%的关系显著，而 Engle Granger 认为 6.5%。他们同意 366 对（0.79%）。

### 启发法预测显著协整的效果如何？

当我们比较根据这两个测试进行协整的序列与未进行协整的剩余序列的启发式分布时，波动性和漂移确实较低（绝对值）。*图 9.14*显示，对于两个相关度量，图片不太清晰：

![](img/15439_09_14.png)

图 9.14：启发式的分布，按两个协整检验的显著性细分

为了评估启发式的预测准确性，我们首先运行具有这些特征的逻辑回归模型来预测显著的协整。曲线（**AUC**交叉验证得分为 0.815 的**区域；除去相关性指标，它仍然得分为 0.804。决策树在 AUC=0.821 时表现稍好，无论有无相关特征。**

尤其是由于类的严重不平衡，存在大量的误报：正确识别 366 个协整对中的 80%意味着超过 16500 个误报，但排除了近 30000 个候选。更多详细信息，请参见笔记本`cointegration_tests`。

**关键要点**是距离启发法可以帮助更有效地筛选一个大宇宙，但这是以缺少一些协整对为代价的，仍然需要大量测试。

## 准备策略回溯测试

在本节中，我们将对股票和 ETF 样本以及 2017-2019 年期间实施基于协整的统计套利策略。简化了某些方面以简化演示。有关代码示例和其他详细信息，请参见笔记本`statistical_arbitrage_with_cointegrated_pairs`。

我们首先生成并存储所有候选对的协整检验以及由此产生的交易信号。然后，考虑到过程的计算强度，我们基于这些信号对策略进行了回溯测试。

### 预计算协整检验

首先，我们在 2 年的回顾期内对 23000 个潜在对进行季度协整检验，然后，我们选择 Johansen 和 Engle Granger 检验都同意交易的对。我们应该排除回望期内固定的资产，但是我们排除了整个期间固定的资产，所以我们跳过这一步来简化它。

该程序遵循前面概述的步骤；详情请参阅笔记本。

*图 9.15*显示了选择交易的两对不同的原始股票和 ETF 系列；请注意，在样本期内明显存在一个共同趋势：

![](img/15439_09_15.png)

图 9.15：样本期内两个选定对的价格序列

### 进入和退出交易

现在，我们可以根据滚动套期保值比率计算每个候选对的利差。我们还计算了一个 To.T0- Bulner-Prand Toul T1 席，因为我们将考虑大于两个滚动标准差的移动的移动，作为其平均移动距离 To 3T.长和短进入信号 T4，以及移动平均值的交叉作为出口信号。

#### 用卡尔曼滤波平滑价格

为此，我们首先应用滚动**卡尔曼滤波器**（**KF**）去除一些噪声，如*第 4 章*、*金融特征工程——如何研究阿尔法因子*：

```py
def KFSmoother(prices):
    """Estimate rolling mean"""

    kf = KalmanFilter(transition_matrices=np.eye(1),
                      observation_matrices=np.eye(1),
                      initial_state_mean=0,
                      initial_state_covariance=1,
                      observation_covariance=1,
                      transition_covariance=.05)
    state_means, _ = kf.filter(prices.values)
    return pd.Series(state_means.flatten(),
                     index=prices.index) 
```

#### 利用卡尔曼滤波计算滚动套期保值比率

为了获得动态套期保值比率，我们使用 KF 进行滚动线性回归，如下所示：

```py
def KFHedgeRatio(x, y):
    """Estimate Hedge Ratio"""
    delta = 1e-3
    trans_cov = delta / (1 - delta) * np.eye(2)
    obs_mat = np.expand_dims(np.vstack([[x], [np.ones(len(x))]]).T, axis=1)
    kf = KalmanFilter(n_dim_obs=1, n_dim_state=2,
                      initial_state_mean=[0, 0],
                      initial_state_covariance=np.ones((2, 2)),
                      transition_matrices=np.eye(2),
                      observation_matrices=obs_mat,
                      observation_covariance=2,
                      transition_covariance=trans_cov)
    state_means, _ = kf.filter(y.values)
    return -state_means 
```

#### 平均回归半衰期的估计

如果我们将利差视为连续时间的均值回复随机过程，我们可以将其建模为 Ornstein-Uhlenbeck 过程。这种观点的好处是，我们得到了均值回归半衰期的公式，作为偏离后价差再次收敛所需时间的近似值（详见《Chan 2013》中的*第 2 章*、*市场和基础数据——来源和技术*：

```py
def estimate_half_life(spread):
    X = spread.shift().iloc[1:].to_frame().assign(const=1)
    y = spread.diff().iloc[1:]
    beta = (np.linalg.inv(X.T@X)@X.T@y).iloc[0]
    halflife = int(round(-np.log(2) / beta, 0))
    return max(halflife, 1) 
```

#### 计算扩展和布林带

以下函数协调了前面的计算，并将价差表示为一个 z 分数，该分数捕捉移动平均线的偏差，窗口等于滚动标准偏差的两个半衰期：

```py
def get_spread(candidates, prices):
    pairs, half_lives = [], []
    periods = pd.DatetimeIndex(sorted(candidates.test_end.unique()))
    start = time()
    for p, test_end in enumerate(periods, 1):
        start_iteration = time()
        period_candidates = candidates.loc[candidates.test_end == test_end, 
                                          ['y', 'x']]
        trading_start = test_end + pd.DateOffset(days=1)
        t = trading_start - pd.DateOffset(years=2)
        T = trading_start + pd.DateOffset(months=6) - pd.DateOffset(days=1)
        max_window = len(prices.loc[t: test_end].index)
        print(test_end.date(), len(period_candidates))
        for i, (y, x) in enumerate(zip(period_candidates.y, 
                                       period_candidates.x), 1):
            pair = prices.loc[t: T, [y, x]]
            pair['hedge_ratio'] = KFHedgeRatio(
                y=KFSmoother(prices.loc[t: T, y]),
                x=KFSmoother(prices.loc[t: T, x]))[:, 0]
            pair['spread'] = pair[y].add(pair[x].mul(pair.hedge_ratio))
            half_life = estimate_half_life(pair.spread.loc[t: test_end])
            spread = pair.spread.rolling(window=min(2 * half_life, 
                                                    max_window))
            pair['z_score'] = pair.spread.sub(spread.mean()).div(spread.
std())
            pairs.append(pair.loc[trading_start: T].assign(s1=y, s2=x, period=p, pair=i).drop([x, y], axis=1))
            half_lives.append([test_end, y, x, half_life])
    return pairs, half_lives 
```

#### 获取多头和空头头寸的进入和退出日期

最后，我们使用 z 分数集来推导交易信号：

1.  如果 z 分数低于（高于）2，我们进入一个长（短）位置，这意味着价差移动了两个滚动标准差低于（高于）移动平均值
2.  当价差再次超过移动平均线时，我们退出交易

我们每季度为在前一回望期通过协整检验但允许配对在随后 3 个月退出的配对集合推导规则。

我们再次通过删除在这 6 个月期间不闭合的对来简化这一过程。或者，我们可以使用策略中包含的止损风险管理（见下一节回溯测试）来处理此问题：

```py
def get_trades(data):
    pair_trades = []
    for i, ((period, s1, s2), pair) in enumerate(
             data.groupby(['period', 's1', 's2']), 1):
        if i % 100 == 0:
            print(i)
        first3m = pair.first('3M').index
        last3m = pair.last('3M').index
        entry = pair.z_score.abs() > 2
        entry = ((entry.shift() != entry)
                 .mul(np.sign(pair.z_score))
                 .fillna(0)
                 .astype(int)
                 .sub(2))
        exit = (np.sign(pair.z_score.shift().fillna(method='bfill'))
                != np.sign(pair.z_score)).astype(int) - 1
        trades = (entry[entry != -2].append(exit[exit == 0])
                  .to_frame('side')
                  .sort_values(['date', 'side'])
                  .squeeze())
        trades.loc[trades < 0] += 2
        trades = trades[trades.abs().shift() != trades.abs()]
        window = trades.loc[first3m.min():first3m.max()]
        extra = trades.loc[last3m.min():last3m.max()]
        n = len(trades)
        if window.iloc[0] == 0:
            if n > 1:
                print('shift')
                window = window.iloc[1:]
        if window.iloc[-1] != 0:
            extra_exits = extra[extra == 0].head(1)
            if extra_exits.empty:
                continue
            else:
                window = window.append(extra_exits)
        trades = (pair[['s1', 's2', 'hedge_ratio', 'period', 'pair']]
                  .join(window. to_frame('side'), how='right'))
        trades.loc[trades.side == 0, 'hedge_ratio'] = np.nan
        trades.hedge_ratio = trades.hedge_ratio.ffill()
        pair_trades.append(trades)
    return pair_trades 
```

## 使用 backtrader 对策略进行回溯测试

现在，我们准备在我们的回溯测试平台上制定我们的策略，执行它，并评估结果。为此，除了个别投资组合头寸外，我们还需要跟踪交易对，并监控活跃和非活跃交易对的价差，以应用我们的交易规则。

### 使用自定义数据类跟踪对

为了解释活动对，我们定义了一个`dataclass`（在 Python 3.7 中引入—有关详细信息，请参阅 Python 文档）。该数据结构称为`Pair`，允许我们存储配对组件、其股票数量和对冲比率，并计算当前利差和回报等。请参见以下代码中的简化版本：

```py
@dataclass
class Pair:
    period: int
    s1: str
    s2: str
    size1: float
    size2: float
    long: bool
    hr: float
    p1: float
    p2: float
    entry_date: date = None
    exit_date: date = None
    entry_spread: float = np.nan
    exit_spread: float = np.nan
    def compute_spread(self, p1, p2):
        return p1 * self.size1 + p2 * self.size2
    def compute_spread_return(self, p1, p2):
        current_spread = self.compute_spread(p1, p2)
        delta = self.entry_spread - current_spread
        return (delta / (np.sign(self.entry_spread) *
                         self.entry_spread)) 
```

### 战略的运行与评估

关键实施方面包括：

*   从触发退出规则或超过给定负回报的配对的每日退出
*   为价差触发进入信号的交易对打开新的多头和空头头寸
*   此外，我们调整位置，以考虑不同的对数

策略代码本身占用了太多空间，无法在此处显示；详见笔记本 `pairs_trading_backtest`。

*图 9.16*显示，至少在 2017-2019 年期间，这一简化战略有其独特之处（请注意，我们利用了一些前瞻性偏见，忽略了交易成本）。

在这些宽松的假设下，该公司在期初和期末的表现均逊于 S&P500，在其他方面大致持平（左图）。其α值为 0.08，负β值为-0.14（右图），平均夏普比为 0.75，索蒂诺比为 1.05（中央图）：

![](img/15439_09_16.png)

图 9.16：战略表现指标

虽然我们应该对这些表现指标持保留态度，但该策略展示了基于成对交易形式协整的统计套利的剖析。让我们看一下您可以在这个框架上建立的几个步骤来产生更好的性能。

## 扩展–如何做得更好

协整是一个非常有用的概念，用于识别倾向于一致运动的成对或组股票。与协整的统计复杂性相比，我们使用了非常简单和静态的交易规则；按季度计算也扭曲了策略，正如多头和空头持有的模式所示（见笔记本）。

要想成功，你至少需要筛选一个更大的范围，并优化几个参数，包括交易规则。此外，风险管理应考虑当某些资产相对频繁地出现在交易对的同一侧时产生的集中头寸。

您还可以使用篮子，而不是单个篮子；然而，为了应对越来越多的候选人，您可能需要限制篮子的组成。

如*配对交易-统计套利与协整*部分所述，有一些替代方案旨在预测价格变动。在接下来的章节中，我们将探讨各种机器学习模型，这些模型旨在预测给定投资领域和范围内的绝对规模或价格变动方向。使用这些预测作为多头和空头进入信号是我们在本节研究的配对交易框架的自然延伸或替代。

# 总结

在本章中，我们探讨了单个序列的单变量情况下的线性时间序列模型，以及几个相互作用序列的多变量模型。我们遇到了预测宏观基本面的应用程序、在风险管理中广泛使用的预测资产或投资组合波动性的模型，以及捕捉多个宏观系列动态的多元 VAR 模型。我们还研究了协整的概念，这是流行的配对交易策略的基础。

类似于*第 7 章*、*线性模型——从风险因子到回报预测*，我们看到了线性模型是如何施加大量结构的，也就是说，它们做出了强有力的假设，可能需要转换和广泛的测试来验证这些假设是否得到满足。如果是的话，模型训练和解释就很简单，而且模型提供了一个良好的基线，更复杂的模型可能能够改进。在接下来的两章中，我们将看到这方面的两个例子，即随机森林和梯度提升模型，我们将在*第 4 部分*中遇到更多关于深度学习的例子。